<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mobbist</title>
      <style>
      :root {
        --bg: #f4f4f4;
        --card-bg: #ffffff;
        --border: #dddddd;
        --accent: #0070f3;
        --accent-soft: #e3f1ff;
        --danger: #b3261e;
        --muted: #666666;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        margin: 24px;
        background: var(--bg);
        color: #111827;
      }

      h1 {
        margin: 0 0 4px;
        font-size: 1.6rem;
      }

      p {
        margin: 0 0 12px;
        color: var(--muted);
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
      }

      .layout-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 16px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
        margin-left: auto;
      }


      .controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: flex-end;
        align-items: center;
      }

      .history-controls {
        border-top: 1px solid var(--border);
        padding-top: 6px;
      }

      .history-shortcuts-hint {
        font-size: 0.7rem;
        color: var(--muted);
        margin-top: 4px;
        text-align: right;
      }

      .controls .history-btn {
        min-width: 180px;
        text-align: left;
      }

      @media (min-width: 768px) {
        .controls {
          align-items: flex-end;
        }

        .controls-row {
          flex-wrap: nowrap;
        }

        .history-controls {
          width: 100%;
        }
      }

      textarea {
        width: 100%;
        min-height: 80px;
        padding: 8px;
        font-size: 14px;
        resize: vertical;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
      }

      button {
        padding: 6px 12px;
        cursor: pointer;
        font-size: 13px;
        border-radius: 4px;
        border: 1px solid var(--border);
        background: #ffffff;
        color: #111827;
      }

      button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #ffffff;
      }

      button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: #ffffff;
      }

      button.ghost {
        background: transparent;
      }

      button:disabled {
        opacity: 0.5;
        cursor: default;
      }

      .tracks-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 8px 0 12px;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tracks-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 12px;
        align-items: flex-start;
      }

      .create-track-drop-zone {
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        border: 2px dashed var(--accent);
        border-radius: 6px;
        background: var(--accent-soft);
        color: var(--accent);
        font-weight: 600;
        min-height: 96px;
        transition: background 120ms ease, color 120ms ease, border-color 120ms ease;
      }

      .create-track-drop-zone.visible {
        display: flex;
      }

      .create-track-drop-zone.hover {
        background: var(--accent);
        color: #ffffff;
        border-color: var(--accent);
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .history-animation-layer {
        position: fixed;
        inset: 0;
        pointer-events: none;
        overflow: visible;
        z-index: 999;
      }

      .history-ghost {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 8px;
        border-radius: 6px;
        background: #ffffff;
        box-shadow: 0 0 0 2px var(--accent);
        font-size: 0.85rem;
        color: #111827;
        pointer-events: none;
        transform: translate(0, 0);
        opacity: 1;
        transform-origin: top left;
        white-space: nowrap;
        will-change: transform, opacity;
      }

      .person.history-flash {
        animation: historyFlash 600ms ease;
      }

      @keyframes historyFlash {
        from {
          background: var(--accent-soft);
        }
        to {
          background: #ffffff;
        }
      }

      .track {
        background: var(--card-bg);
        border-radius: 6px;
        border: 1px solid var(--border);
        padding: 8px;
        display: flex;
        flex-direction: column;
        min-height: 120px;
      }

      .track-locked {
        border-color: #c7d2fe;
        background: #f8fafc;
        box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.15);
      }

      .track-locked .people-list,
      .track-locked .roles-list {
        background: #eef2ff;
        box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.12);
      }

      .track-lock-toggle {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        font-size: 0.75rem;
        line-height: 1.2;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #ffffff;
        transition: background-color 120ms ease, border-color 120ms ease, color 120ms ease;
      }

      .track-lock-toggle[data-locked='true'] {
        background: var(--accent-soft);
        border-color: var(--accent);
        color: var(--accent);
      }

      .track-lock-toggle[data-locked='true']:hover {
        background: var(--accent);
        color: #ffffff;
      }

      .track-lock-toggle:not([data-locked='true']):hover {
        background: rgba(0, 112, 243, 0.08);
        border-color: var(--accent);
      }

      .track-header {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 6px;
      }

      .track-header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        min-width: 0;
      }

      .track-title {
        font-weight: 600;
        font-size: 0.95rem;
        word-break: break-word;
        overflow-wrap: anywhere;
        min-width: 0;
      }

      .track-type {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }

      .track-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        font-size: 0.75rem;
      }

      .capacity-input {
        width: 60px;
        padding: 3px 4px;
        font-size: 0.75rem;
      }

      .track-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }

      .tenure-config-button {
        padding: 2px 6px;
        font-size: 0.7rem;
        border-radius: 4px;
        border: 1px solid var(--border);
        background: #ffffff;
        cursor: pointer;
      }

      .tenure-config-button:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .tenure-config-button[data-overridden='true'] {
        background: rgba(59, 130, 246, 0.12);
        border-color: rgba(59, 130, 246, 0.4);
        color: #1d4ed8;
      }

      .people-list {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 4px;
        border-radius: 4px;
        background: #f9fafb;
        min-height: 60px;
        max-height: 260px;
        overflow-y: auto;
      }

      .people-list.empty {
        font-size: 0.8rem;
        color: var(--muted);
        align-items: center;
        justify-content: center;
        display: flex;
      }

      .people-list.drop-target {
        outline: 2px dashed var(--accent);
        background: var(--accent-soft);
      }

      .people-list.drop-target-locked,
      .roles-list.drop-target-locked {
        outline-style: dashed;
        outline-color: #f97316;
        background: rgba(249, 115, 22, 0.16);
      }

      .people-list.drop-target-full,
      .roles-list.drop-target-full {
        outline-style: dashed;
        outline-color: #fbbf24;
        background: rgba(251, 191, 36, 0.18);
      }

      .track-drop-target {
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.35);
      }

      .track-drop-target-locked {
        box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.5);
      }

      .track-drop-target-full {
        box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.45);
      }

      .roles-list {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 4px;
        border-radius: 4px;
        background: #f3f4f6;
        min-height: 44px;
        max-height: 200px;
        overflow-y: auto;
        margin-top: 6px;
      }

      .roles-list.empty {
        font-size: 0.75rem;
        color: var(--muted);
        align-items: center;
        justify-content: center;
        display: flex;
      }

      .roles-list.drop-target {
        outline: 2px dashed var(--accent);
        background: var(--accent-soft);
      }

      .role-pill {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 8px 12px;
        border-radius: 18px;
        background: #ffffff;
        border: 1px solid var(--border);
        font-size: 0.8rem;
      }

      .role-info {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }

      .role-name {
        font-weight: 600;
        overflow-wrap: anywhere;
      }

      .role-color-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--accent);
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      .role-actions {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
      }

      .role-actions button,
      .role-actions select {
        padding: 2px 6px;
        font-size: 0.7rem;
      }

      .role-delete {
        border-color: var(--danger);
        background: #ffffff;
        color: var(--danger);
      }

      .person-actions,
      .role-actions {
        min-width: 0;
      }

      .person-actions .actions-left,
      .role-actions .actions-left {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
        flex: 1 1 auto;
        min-width: 0;
      }

      .person-actions .actions-right,
      .role-actions .actions-right {
        display: flex;
        align-items: center;
        gap: 6px;
        flex: 0 0 auto;
      }

      .person {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 6px;
        flex-wrap: wrap;
        padding: 4px 6px;
        border-radius: 4px;
        background: #ffffff;
        border: 1px solid var(--border);
        font-size: 0.85rem;
        cursor: grab;
      }

      .person:active {
        cursor: grabbing;
      }

      .person.person-dragging {
        opacity: 0.85;
      }

      .person-header {
        display: flex;
        align-items: center;
        gap: 6px;
        flex: 1 1 auto;
        min-width: 0;
      }

      .person-tenure-soft {
        box-shadow: inset 0 0 0 1px rgba(234, 179, 8, 0.45);
        background: linear-gradient(90deg, rgba(234, 179, 8, 0.12), #ffffff);
      }

      .person-tenure-hard {
        box-shadow: inset 0 0 0 1px rgba(220, 38, 38, 0.5);
        background: linear-gradient(90deg, rgba(248, 113, 113, 0.16), #ffffff);
      }

      .person-tenure-indicator {
        border: 1px solid transparent;
        border-radius: 999px;
        padding: 2px 6px;
        font-size: 0.7rem;
        line-height: 1.1;
        background: rgba(15, 23, 42, 0.05);
        color: #334155;
        cursor: pointer;
        flex: 0 0 auto;
        align-self: center;
      }

      .person-tenure-indicator-soft {
        background: rgba(234, 179, 8, 0.18);
        color: #92400e;
      }

      .person-tenure-indicator-hard {
        background: rgba(220, 38, 38, 0.2);
        color: #991b1b;
      }

      .person-tenure-indicator:hover {
        border-color: rgba(0, 0, 0, 0.08);
      }

      .person-tenure-indicator:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .person-name {
        flex: 1 1 auto;
        word-break: break-word;
        overflow-wrap: anywhere;
        min-width: 0;
      }

      .person-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: space-between;
      }

      .person-actions button {
        padding: 2px 6px;
        font-size: 0.7rem;
      }

      .person-actions .retire-button {
        border-color: var(--danger);
        color: var(--danger);
        background: #ffffff;
        margin-left: auto;
        flex-shrink: 0;
      }

      .person-actions .retire-button[data-state='confirm'] {
        border-color: #2563eb;
        color: #ffffff;
        background: #2563eb;
      }

      .person-pending-retire {
        background: #fef2f2;
      }

      .person-pending-retire .person-name::after {
        content: ' (retiring…)';
        font-size: 0.75rem;
        color: var(--danger);
      }

      .person-actions select,
      .role-actions select {
        padding: 2px 6px;
        font-size: 0.7rem;
        min-width: 110px;
        flex: 0 0 110px;
      }

      @media (min-width: 640px) {
        .person-actions,
        .role-actions {
          flex-wrap: nowrap;
        }
      }

      @media (min-width: 768px) {
        .person-actions button[data-label]::after,
        .role-actions button[data-label]::after {
          content: ' ' attr(data-label);
        }
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e5e7eb;
        font-size: 0.7rem;
      }

      .badge-locked {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.15);
        color: #1d4ed8;
        font-size: 0.65rem;
        font-weight: 600;
        letter-spacing: 0.03em;
        text-transform: uppercase;
      }

      .badge-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--accent);
        margin-right: 4px;
      }

      .muted {
        color: var(--muted);
      }

      .backend-status {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        padding: 10px 12px;
        background: #ffffff;
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
      }

      .backend-status-top {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .backend-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 600;
        background: #e5e7eb;
        color: #111827;
      }

      .backend-badge[data-status='connected'] {
        background: rgba(16, 185, 129, 0.15);
        color: #065f46;
        border: 1px solid rgba(16, 185, 129, 0.4);
      }

      .backend-badge[data-status='offline'],
      .backend-badge[data-status='unknown'] {
        background: rgba(239, 68, 68, 0.12);
        color: #991b1b;
        border: 1px solid rgba(239, 68, 68, 0.35);
      }

      .backend-controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        width: 100%;
      }

      .backend-controls-row input[type='url'] {
        flex: 1;
        min-width: 220px;
        padding: 8px;
        border: 1px solid var(--border);
        border-radius: 6px;
      }

      .backend-controls-row button {
        white-space: nowrap;
      }

      .track-full {
        border-color: #f97316;
      }

      @media (max-width: 600px) {
        body {
          margin: 12px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="layout-header">
        <div>
          <h1>Mobbist</h1>
          <p>Plan pairs and mobs and reshuffle people quickly in your browser.</p>
        </div>
        <div class="controls">
          <div class="controls-row primary-controls">
            <button id="addRoleButton" class="primary">Add role</button>
            <button id="shuffleRolesButton" class="ghost" disabled>Shuffle roles</button>
            <button id="resetPlanButton" class="ghost">Reset plan</button>
          </div>
          <div class="controls-row history-controls">
            <button id="undoButton" class="ghost history-btn" disabled>Undo</button>
            <button id="redoButton" class="ghost history-btn" disabled>Redo</button>
          </div>
          <div class="controls-row clipboard-controls">
            <button id="exportClipboardButton" class="ghost">Copy board as Markdown</button>
            <button id="importClipboardButton" class="ghost">Import board from clipboard</button>
          </div>
          <div class="history-shortcuts-hint" aria-hidden="true">
            Undo: ⌘Z / Ctrl+Z · Redo: ⇧⌘Z / Ctrl+Shift+Z / Ctrl+Y
          </div>
        </div>
      </div>

      <section class="backend-status" aria-label="Backend status and settings">
        <div class="backend-status-top">
          <div id="backendStatusBadge" class="backend-badge" data-status="unknown">Local fallback</div>
          <span class="muted" style="font-size:0.85rem;">Backend optional; falls back to local when unreachable.</span>
        </div>
        <div class="backend-controls-row">
          <input
            id="backendUrlInput"
            type="url"
            inputmode="url"
            placeholder="https://api.example.com"
            aria-label="Backend base URL"
          />
          <button id="checkBackendButton" class="ghost">Save &amp; Check</button>
          <button id="loadBackendButton" class="ghost">Load from Backend</button>
          <button id="saveBackendButton" class="primary">Save to Backend</button>
          <button id="revertToLocalButton" class="danger">Revert to Local</button>
        </div>
      </section>

      <section class="stack">
        <label for="bulkNamesInput" style="font-size:0.85rem;">Add people (one name per line):</label>
        <textarea
          id="bulkNamesInput"
          placeholder="Alice&#10;Bob&#10;Charlie&#10;Dana"
        ></textarea>
        <div>
          <button id="addPeopleButton" class="primary">Add people to On Deck</button>
        </div>
      </section>

      <section class="tracks-toolbar">
        <div class="muted" style="font-size:0.8rem;">
          Tracks: On Deck distributes into all normal tracks. Out of Office is excluded from random allocation.
          Automatic: Dragging a person to the drop zone creates a fresh track, and allocation or shuffle actions add lanes when capacity runs out.
        </div>
        <div class="muted" style="font-size:0.75rem; display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
           <label for="defaultCapacityInput">Default capacity:</label>
           <input id="defaultCapacityInput" type="number" min="1" value="2" style="width:3rem; padding:2px 4px; font-size:0.75rem;" />
           <label for="tenureSoftInput">Soft warn (days):</label>
           <input id="tenureSoftInput" type="number" min="0.1" step="0.1" value="2" style="width:3rem; padding:2px 4px; font-size:0.75rem;" />
           <label for="tenureHardInput">Strong warn (days):</label>
           <input id="tenureHardInput" type="number" min="0.1" step="0.1" value="4" style="width:3rem; padding:2px 4px; font-size:0.75rem;" />
           <button id="sweepAllTracksButton" class="primary" disabled>Sweep all tracks</button>
           <button id="sortTenureButton" class="ghost" disabled>Sort by tenure</button>
           <button id="listStrongTenureButton" class="ghost">Highlight strong alerts</button>
           <button id="deleteSelectedTracksButton" class="danger" disabled>Delete selected tracks</button>
           <button id="deleteAllTracksButton" class="danger" disabled>Delete all tracks</button>
         </div>
         <div id="capacityNotice" class="muted" style="font-size:0.75rem;"></div>


      </section>

      <section id="tracksContainer" class="tracks-grid" aria-label="Tracks"></section>
      <div id="historyAnnouncer" class="visually-hidden" aria-live="polite" aria-atomic="true"></div>
      <div id="historyOverlay" class="history-animation-layer"></div>
    </main>

    <script>
      ;(function () {
        const STORAGE_KEY = 'mobbist:v1'
        const LEGACY_STORAGE_KEYS = ['pairPlanner:v1']
        const CONFIG_STORAGE_KEY = 'mobbist:config:v1'
        const WORKSPACE_META_KEY = 'mobbist:workspace-meta:v1'
        const BACKEND_CHECK_TIMEOUT_MS = 4000
        const NEW_TRACK_OPTION_VALUE = '__create_new_track__'
        const HISTORY_LIMIT = 30
        const DEFAULT_TENURE_SOFT_DAYS = 2
        const DEFAULT_TENURE_HARD_DAYS = 4
        const CLIPBOARD_FORMAT_ID = 'mobbist.markdown'
        const CLIPBOARD_FORMAT_VERSION = '1'
        const CLIPBOARD_SUPPORTED_MAJOR_VERSION = 1
        let clipboardAutoLoadAttempted = false

        /**
         * @typedef {{ id: string, name: string }} Person
         * @typedef {{ id: string, name: string, color: string | null }} Role
         * @typedef {{ id: string, name: string, type: 'normal' | 'on_deck' | 'out_of_office', capacity: number | null, personIds: string[], roleIds: string[], locked?: boolean }} Track
         * @typedef {{ softDays: number, hardDays: number }} TenureThresholds
         * @typedef {{ trackId: string, assignedAt: number }} TenureAssignment
         * @typedef {{ assignments: { [personId: string]: TenureAssignment | undefined }, overrides: { [trackId: string]: Partial<TenureThresholds> | undefined }, config: TenureThresholds }} TenureState
         * @typedef {{ people: Person[], roles: Role[], tracks: Track[], nextPersonId: number, nextTrackId: number, nextRoleId: number, defaultTrackCapacity: number, tenure: TenureState }} PlannerState
         * @typedef {{ backendUrl: string, reachability: 'unknown' | 'connected' | 'offline', lastCheckedAt: number | null }} BackendConfig
         * @typedef {{ workspaceId: string | null, clientTempId: string, persisted: boolean }} WorkspaceMeta
         */

        function normalizeBackendUrl(url) {
          if (!url) return ''
          const trimmed = String(url).trim()
          if (!trimmed) return ''
          const withoutTrailing = trimmed.replace(/\/+$/, '')
          if (/^https?:\/\//i.test(withoutTrailing)) {
            return withoutTrailing
          }
          return `https://${withoutTrailing}`
        }

        /** @returns {BackendConfig} */
        function createDefaultBackendConfig() {
          return {
            backendUrl: '',
            reachability: 'unknown',
            lastCheckedAt: null,
          }
        }

        /** @returns {BackendConfig} */
        function loadBackendConfig() {
          try {
            const raw = window.localStorage.getItem(CONFIG_STORAGE_KEY)
            if (!raw) return createDefaultBackendConfig()
            const parsed = JSON.parse(raw)
            const backendUrl = normalizeBackendUrl(parsed.backendUrl || '')
            const reachability =
              parsed.reachability === 'connected' || parsed.reachability === 'offline'
                ? parsed.reachability
                : 'unknown'
            const lastCheckedAt = typeof parsed.lastCheckedAt === 'number' ? parsed.lastCheckedAt : null
            return { backendUrl, reachability, lastCheckedAt }
          } catch (e) {
            console.warn('Failed to load backend config, resetting.', e)
            return createDefaultBackendConfig()
          }
        }

        /** @param {BackendConfig} config */
        function saveBackendConfig(config) {
          try {
            window.localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(config))
          } catch (e) {
            console.warn('Failed to save backend config.', e)
          }
        }

        /** @param {'unknown' | 'connected' | 'offline'} status */
        function updateBackendStatusBadge(status) {
          const badge = document.getElementById('backendStatusBadge')
          if (!badge) return
          badge.textContent = status === 'connected' ? 'Backend connected' : 'Local fallback'
          badge.dataset.status = status
        }

        /** @returns {WorkspaceMeta} */
        function createDefaultWorkspaceMeta() {
          return {
            workspaceId: null,
            clientTempId: `temp-${Date.now()}`,
            persisted: false,
          }
        }

        /** @returns {WorkspaceMeta} */
        function loadWorkspaceMeta() {
          try {
            const raw = window.localStorage.getItem(WORKSPACE_META_KEY)
            if (!raw) return createDefaultWorkspaceMeta()
            const parsed = JSON.parse(raw)
            return {
              workspaceId: typeof parsed.workspaceId === 'string' && parsed.workspaceId.trim() ? parsed.workspaceId.trim() : null,
              clientTempId: typeof parsed.clientTempId === 'string' && parsed.clientTempId.trim() ? parsed.clientTempId.trim() : `temp-${Date.now()}`,
              persisted: Boolean(parsed.persisted),
            }
          } catch (e) {
            console.warn('Failed to load workspace meta, resetting.', e)
            return createDefaultWorkspaceMeta()
          }
        }

        /** @param {WorkspaceMeta} meta */
        function saveWorkspaceMeta(meta) {
          try {
            window.localStorage.setItem(WORKSPACE_META_KEY, JSON.stringify(meta))
          } catch (e) {
            console.warn('Failed to save workspace meta.', e)
          }
        }

        function isBackendEnabled() {
          return backendConfig.backendUrl && backendConfig.reachability === 'connected'
        }

        async function checkBackendReachability() {
          const normalizedUrl = normalizeBackendUrl(backendConfig.backendUrl)
          if (!normalizedUrl) {
            backendConfig.reachability = 'offline'
            backendConfig.lastCheckedAt = Date.now()
            saveBackendConfig(backendConfig)
            updateBackendStatusBadge(backendConfig.reachability)
            return backendConfig.reachability
          }

          const controller = new AbortController()
          const timeoutId = window.setTimeout(() => controller.abort(), BACKEND_CHECK_TIMEOUT_MS)
          try {
            const response = await fetch(`${normalizedUrl}/capabilities`, {
              method: 'GET',
              headers: { Accept: 'application/json' },
              signal: controller.signal,
            })
            backendConfig.reachability = response.ok ? 'connected' : 'offline'
          } catch (err) {
            backendConfig.reachability = 'offline'
          } finally {
            window.clearTimeout(timeoutId)
            backendConfig.lastCheckedAt = Date.now()
            saveBackendConfig(backendConfig)
            updateBackendStatusBadge(backendConfig.reachability)
          }
          return backendConfig.reachability
        }

        async function loadFromBackend() {
          if (!isBackendEnabled() || !workspaceMeta.workspaceId) return false
          if (dirtySinceServerLoad) {
            const confirmed = window.confirm('Reloading from server will discard local changes.')
            if (!confirmed) return false
          }
          const url = `${backendConfig.backendUrl}/workspaces/${workspaceMeta.workspaceId}`
          try {
            const response = await fetch(url, {
              method: 'GET',
              headers: { Accept: 'application/json' },
            })
            if (!response.ok) {
              console.warn('Backend load failed', response.status)
              return false
            }
            const data = await response.json()
            if (!data || typeof data !== 'object' || !data.data) {
              console.warn('Backend load returned invalid payload')
              return false
            }
            state = data.data
            saveState()
            workspaceMeta.persisted = true
            saveWorkspaceMeta(workspaceMeta)
            dirtySinceServerLoad = false
            render()
            return true
          } catch (err) {
            console.warn('Backend load error', err)
            return false
          }
        }

        async function saveToBackend() {
          if (!isBackendEnabled()) return false
          const snapshot = { id: workspaceMeta.workspaceId, name: 'Workspace', data: state }
          const method = workspaceMeta.workspaceId ? 'PUT' : 'POST'
          const url = workspaceMeta.workspaceId
            ? `${backendConfig.backendUrl}/workspaces/${workspaceMeta.workspaceId}`
            : `${backendConfig.backendUrl}/workspaces`
          try {
            const response = await fetch(url, {
              method,
              headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
              body: JSON.stringify(
                method === 'POST'
                  ? { ...snapshot, clientTempId: workspaceMeta.clientTempId }
                  : snapshot,
              ),
            })
            if (!response.ok) {
              console.warn('Backend save failed', response.status)
              return false
            }
            const data = await response.json()
            if (data && data.id) {
              workspaceMeta.workspaceId = data.id
              workspaceMeta.persisted = true
              saveWorkspaceMeta(workspaceMeta)
            }
            dirtySinceServerLoad = false
            return true
          } catch (err) {
            console.warn('Backend save error', err)
            return false
          }
        }

        function revertToLocal() {
          backendConfig.backendUrl = ''
          backendConfig.reachability = 'offline'
          backendConfig.lastCheckedAt = Date.now()
          saveBackendConfig(backendConfig)
          updateBackendStatusBadge(backendConfig.reachability)
        }
 
 
         function formatClipboardTokens(entries) {
           if (!entries || !entries.length) return ''
           const parts = []
           for (const entry of entries) {
             if (!entry || !entry.key) continue
             const key = String(entry.key).trim().toLowerCase()
             if (!key) continue
             if (entry.value == null || entry.value === '') {
               parts.push(`[${key}]`)
             } else {
               const value = String(entry.value).replace(/([\[\]])/g, '\\$1')
               parts.push(`[${key}:${value}]`)
             }
           }
           return parts.length ? ' ' + parts.join(' ') : ''
         }
 
         function parseBracketTokens(segment) {
           if (typeof segment !== 'string') {
             return { text: '', tokens: {} }
           }
           const tokenRegex = /\[([^\[\]]+)\]/g
           const tokens = {}
           let match
           while ((match = tokenRegex.exec(segment))) {
             const tokenContent = match[1].trim()
             if (!tokenContent) continue
             const unescaped = tokenContent.replace(/\\([\[\]])/g, '$1')
             const colonIndex = unescaped.indexOf(':')
             if (colonIndex === -1) {
               tokens[unescaped.toLowerCase()] = true
             } else {
               const key = unescaped.slice(0, colonIndex).trim().toLowerCase()
               const value = unescaped.slice(colonIndex + 1).trim()
               if (key) {
                 tokens[key] = value
               }
             }
           }
           const text = segment.replace(/\s*\[[^\[\]]+\]\s*/g, ' ').replace(/\s{2,}/g, ' ').trim()
           return { text, tokens }
         }
 
         function normalizePositiveNumber(value) {

          if (value == null) return null
          const numeric = Number(value)
          if (!Number.isFinite(numeric) || numeric <= 0) return null
          return numeric
        }

        function normalizeTenureThresholds(input) {
          const soft = normalizePositiveNumber(input && input.softDays)
          const hard = normalizePositiveNumber(input && input.hardDays)
          let softDays = soft != null ? soft : DEFAULT_TENURE_SOFT_DAYS
          let hardDays = hard != null ? hard : Math.max(softDays, DEFAULT_TENURE_HARD_DAYS)
          if (hardDays < softDays) {
            hardDays = softDays
          }
          return { softDays, hardDays }
        }

        function normalizeTenureOverride(override, fallback) {
          if (!override || typeof override !== 'object') {
            return {}
          }
          const soft = normalizePositiveNumber(override.softDays)
          const hard = normalizePositiveNumber(override.hardDays)
          if (soft == null && hard == null) {
            return {}
          }
          let softDays = soft != null ? soft : fallback.softDays
          let hardDays = hard != null ? hard : fallback.hardDays
          if (hardDays < softDays) {
            hardDays = softDays
          }
          return {
            softDays,
            hardDays,
          }
        }

        function createInitialTenureState() {
          return {
            assignments: {},
            overrides: {},
            config: {
              softDays: DEFAULT_TENURE_SOFT_DAYS,
              hardDays: DEFAULT_TENURE_HARD_DAYS,
            },
          }
        }

        function ensureTenureState(raw) {
          const base = raw && typeof raw === 'object' ? raw : {}
          const config = normalizeTenureThresholds(base.config || {})
          const overrides = {}
          if (base.overrides && typeof base.overrides === 'object') {
            Object.keys(base.overrides).forEach((trackId) => {
              const normalized = normalizeTenureOverride(base.overrides[trackId], config)
              if (normalized.softDays != null && normalized.hardDays != null) {
                overrides[trackId] = normalized
              }
            })
          }
          const assignments = {}
          if (base.assignments && typeof base.assignments === 'object') {
            Object.keys(base.assignments).forEach((personId) => {
              const entry = base.assignments[personId]
              const trackId =
                entry && typeof entry.trackId === 'string' && entry.trackId.trim().length
                  ? entry.trackId
                  : null
              const assignedAt = entry ? normalizePositiveNumber(entry.assignedAt) : null
              if (trackId && assignedAt != null) {
                assignments[personId] = { trackId, assignedAt }
              }
            })
          }
          return {
            assignments,
            overrides,
            config,
          }
        }

        function ensureTenureContainer() {
          if (!state.tenure) {
            state.tenure = createInitialTenureState()
          }
        }

        function clearPersonTenure(personId) {
          ensureTenureContainer()
          if (state.tenure.assignments[personId]) {
            delete state.tenure.assignments[personId]
          }
        }

        function recordTenureAssignment(personId, targetTrack) {
          ensureTenureContainer()
          if (!targetTrack || targetTrack.type !== 'normal') {
            clearPersonTenure(personId)
            return
          }
          const existing = state.tenure.assignments[personId]
          if (existing && existing.trackId === targetTrack.id) {
            return
          }
          state.tenure.assignments[personId] = {
            trackId: targetTrack.id,
            assignedAt: Date.now(),
          }
        }

        function getTenureAssignment(personId) {
          ensureTenureContainer()
          return state.tenure.assignments[personId] || null
        }

        function getEffectiveTenureThresholds(trackId) {
          ensureTenureContainer()
          const override = state.tenure.overrides[trackId]
          if (override && override.softDays != null && override.hardDays != null) {
            return {
              softDays: override.softDays,
              hardDays: override.hardDays,
            }
          }
          return {
            softDays: state.tenure.config.softDays,
            hardDays: state.tenure.config.hardDays,
          }
        }

        function hasTrackTenureOverride(trackId) {
          ensureTenureContainer()
          return Boolean(state.tenure.overrides[trackId])
        }

        function updateTrackTenureOverride(trackId, softDays, hardDays) {
          ensureTenureContainer()
          if (softDays == null && hardDays == null) {
            if (state.tenure.overrides[trackId]) {
              delete state.tenure.overrides[trackId]
              return true
            }
            return false
          }
          const normalized = normalizeTenureOverride({ softDays, hardDays }, state.tenure.config)
          if (!normalized.softDays || !normalized.hardDays) {
            return false
          }
          if (
            normalized.softDays === state.tenure.config.softDays &&
            normalized.hardDays === state.tenure.config.hardDays
          ) {
            if (state.tenure.overrides[trackId]) {
              delete state.tenure.overrides[trackId]
              return true
            }
            return false
          }
          const existing = state.tenure.overrides[trackId]
          if (
            existing &&
            existing.softDays === normalized.softDays &&
            existing.hardDays === normalized.hardDays
          ) {
            return false
          }
          state.tenure.overrides[trackId] = normalized
          return true
        }

        function clearTrackTenureOverride(trackId) {
          ensureTenureContainer()
          if (state.tenure.overrides[trackId]) {
            delete state.tenure.overrides[trackId]
            return true
          }
          return false
        }

        function getTrackTenureOverride(trackId) {
          ensureTenureContainer()
          return state.tenure.overrides[trackId] || null
        }

        function formatTenureThresholdValue(value) {
          if (!Number.isFinite(value)) return ''
          return Number.isInteger(value) ? String(value) : value.toFixed(1).replace(/\.0$/, '')
        }

        function setGlobalTenureConfig(softDays, hardDays) {
          const normalized = normalizeTenureThresholds({ softDays, hardDays })
          const description = `Set global tenure thresholds to ${formatTenureThresholdValue(normalized.softDays)}/${formatTenureThresholdValue(normalized.hardDays)} day(s)`
          return mutateState(description, () => {
            ensureTenureContainer()
            const current = state.tenure.config
            if (
              current.softDays === normalized.softDays &&
              current.hardDays === normalized.hardDays
            ) {
              return false
            }
            state.tenure.config = normalized
            const overrides = state.tenure.overrides
            for (const trackId of Object.keys(overrides)) {
              const normalizedOverride = normalizeTenureOverride(overrides[trackId], normalized)
              if (
                normalizedOverride.softDays === normalized.softDays &&
                normalizedOverride.hardDays === normalized.hardDays
              ) {
                delete overrides[trackId]
              } else {
                overrides[trackId] = normalizedOverride
              }
            }
            return true
          })
        }

        function getPersonTenureStatus(personId, track) {
          if (!track || track.type !== 'normal') return null
          const assignment = getTenureAssignment(personId)
          if (!assignment || assignment.trackId !== track.id) return null
          const thresholds = getEffectiveTenureThresholds(track.id)
          const elapsedMs = Math.max(0, Date.now() - assignment.assignedAt)
          const days = elapsedMs / (1000 * 60 * 60 * 24)
          let status = 'ok'
          if (days >= thresholds.hardDays) {
            status = 'hard'
          } else if (days >= thresholds.softDays) {
            status = 'soft'
          }
          return {
            status,
            days,
            thresholds,
            assignedAt: assignment.assignedAt,
          }
        }

        function formatTenureDuration(days) {
          if (!Number.isFinite(days)) return ''
          if (days >= 7) {
            return `${Math.round(days)}d`
          }
          if (days >= 1) {
            const rounded = Math.round(days * 10) / 10
            return `${rounded}d`
          }
          const hours = days * 24
          if (hours >= 1) {
            return `${Math.round(hours)}h`
          }
          const minutes = Math.max(1, Math.round(hours * 60))
          return `${minutes}m`
        }

        function collectTenureBreaches(level = 'soft') {
          ensureTenureContainer()
          const results = []
          for (const track of state.tracks) {
            if (track.type !== 'normal') continue
            for (const personId of track.personIds) {
              const person = getPersonById(personId)
              if (!person) continue
              const status = getPersonTenureStatus(personId, track)
              if (!status) continue
              if (level === 'hard') {
                if (status.status === 'hard') {
                  results.push({ person, track, status })
                }
              } else if (status.status === 'soft' || status.status === 'hard') {
                results.push({ person, track, status })
              }
            }
          }
          return results
        }

        function hasStrongTenureBreaches() {
          return collectTenureBreaches('hard').length > 0
        }

        function announceStrongTenureBreaches() {
          const breaches = collectTenureBreaches('hard')
          if (!breaches.length) {
            alert('No one exceeds the strong tenure threshold.')
            return
          }
          const lines = breaches
            .map(({ person, track, status }) => {
              const duration = formatTenureDuration(status.days)
              return `${person.name} — ${track.name} (${duration})`
            })
            .join('\n')
          alert(`People exceeding the strong tenure threshold:\n\n${lines}`)
        }

        function sortTracksByTenure() {
          return mutateState('Sort tracks by tenure (longest first)', () => {
            let changed = false
            for (const track of state.tracks) {
              if (track.type !== 'normal' || track.personIds.length < 2) continue
              const sorted = [...track.personIds]
              sorted.sort((a, b) => {
                const aAssignment = getTenureAssignment(a)
                const bAssignment = getTenureAssignment(b)
                const aValue = aAssignment ? aAssignment.assignedAt : Infinity
                const bValue = bAssignment ? bAssignment.assignedAt : Infinity
                if (aValue === bValue) return 0
                return aValue - bValue
              })
              let differs = false
              for (let i = 0; i < sorted.length; i++) {
                if (sorted[i] !== track.personIds[i]) {
                  differs = true
                  break
                }
              }
              if (differs) {
                track.personIds = sorted
                changed = true
              }
            }
            return changed
          })
        }

        /** @type {PlannerState} */
        let state
        /** @type {BackendConfig} */
        let backendConfig = loadBackendConfig()
        /** @type {WorkspaceMeta} */
        let workspaceMeta = loadWorkspaceMeta()
        let currentDragPersonId = null
        let currentDragPersonEl = null
        let currentDragRoleId = null
        let pendingRetirePersonId = null
        /** @type {Set<string>} */
        let selectedTrackIds = new Set()
        /** @type {{ description: string, state: PlannerState }[]} */
        let undoStack = []
        /** @type {{ description: string, state: PlannerState }[]} */
        let redoStack = []
        let pendingHistoryAnnouncement = ''
        let pendingAnimationPositions = null
        let pendingAnimatedPersonIds = null
        let historyAnnouncerEl = null
        let undoButtonEl = null
        let redoButtonEl = null
        let historyShortcutBound = false
        let historyOverlayEl = null
        let suppressTenureIndicatorClickUntil = 0
        let dirtySinceServerLoad = false

        function createInitialState() {

          return {
            people: [],
            roles: [],
            tracks: [
              {
                id: 'on_deck',
                name: 'On Deck',
                type: 'on_deck',
                capacity: null,
                personIds: [],
                roleIds: [],
                locked: false,
              },
              {
                id: 'out_of_office',
                name: 'Out of Office',
                type: 'out_of_office',
                capacity: null,
                personIds: [],
                roleIds: [],
                locked: false,
              },
              {
                id: 'track-1',
                name: 'Track A',
                type: 'normal',
                capacity: 2,
                personIds: [],
                roleIds: [],
                locked: false,
              },
            ],
            nextPersonId: 1,
            nextTrackId: 2,
            nextRoleId: 1,
            defaultTrackCapacity: 2,
            tenure: createInitialTenureState(),
          }
        }

        function ensureHistoryOverlay() {
          if (historyOverlayEl && document.body.contains(historyOverlayEl)) {
            return historyOverlayEl
          }
          historyOverlayEl = document.getElementById('historyOverlay')
          if (!historyOverlayEl) {
            historyOverlayEl = document.createElement('div')
            historyOverlayEl.id = 'historyOverlay'
            historyOverlayEl.className = 'history-animation-layer'
            document.body.appendChild(historyOverlayEl)
          }
          return historyOverlayEl
        }

        function loadState() {
          try {
            let raw = window.localStorage.getItem(STORAGE_KEY)
            if (!raw) {
              for (const legacyKey of LEGACY_STORAGE_KEYS) {
                raw = window.localStorage.getItem(legacyKey)
                if (raw) break
              }
            }
            if (!raw) return createInitialState()
            const parsed = JSON.parse(raw)
            if (!parsed || !Array.isArray(parsed.people) || !Array.isArray(parsed.tracks)) {
              return createInitialState()
            }
            if (!Array.isArray(parsed.roles)) {
              parsed.roles = []
            }
            parsed.roles = parsed.roles.map((role, index) => {
              const id = typeof role.id === 'string' && role.id.trim() ? role.id : `role-${index + 1}`
              const name = typeof role.name === 'string' && role.name.trim() ? role.name.trim() : `Role ${index + 1}`
              const color = typeof role.color === 'string' && role.color.trim() ? role.color.trim() : null
              return { id, name, color }
            })
            const roleIdSet = new Set(parsed.roles.map((role) => role.id))
            const assignedRoleIds = new Set()
            const orphanRoleIds = []
            const defaultCapacity =
              typeof parsed.defaultTrackCapacity === 'number' && parsed.defaultTrackCapacity >= 1
                ? parsed.defaultTrackCapacity
                : 2

            parsed.tracks = parsed.tracks.map((track, index) => {
              const personIds = Array.isArray(track.personIds) ? track.personIds : []
              let roleIds = Array.isArray(track.roleIds) ? track.roleIds.filter((id) => roleIdSet.has(id)) : []
              if (track.type !== 'normal') {
                if (roleIds.length) {
                  orphanRoleIds.push(...roleIds)
                }
                return {
                  ...track,
                  personIds,
                  roleIds: [],
                  locked: Boolean(track.locked),
                }
              }
              roleIds.forEach((id) => assignedRoleIds.add(id))
              return {
                ...track,
                id: typeof track.id === 'string' && track.id.trim() ? track.id : `track-${index}`,
                name: typeof track.name === 'string' && track.name.trim() ? track.name : `Track ${index}`,
                type: 'normal',
                capacity:
                  typeof track.capacity === 'number' && track.capacity >= 1
                    ? track.capacity
                    : track.capacity === null
                      ? null
                      : defaultCapacity,
                personIds,
                roleIds,
                locked: Boolean(track.locked),
              }
            })

            const normalTracks = parsed.tracks.filter((track) => track.type === 'normal')
            if (!normalTracks.length) {
              parsed.tracks.push({
                id: 'track-1',
                name: 'Track A',
                type: 'normal',
                capacity: 2,
                personIds: [],
                roleIds: [],
                locked: false,
              })
            }

            const fallbackTrack = parsed.tracks.find((track) => track.type === 'normal')
            if (fallbackTrack) {
              const unassignedRoleIds = parsed.roles
                .map((role) => role.id)
                .filter((id) => !assignedRoleIds.has(id))
              const unique = new Set([...fallbackTrack.roleIds, ...orphanRoleIds, ...unassignedRoleIds])
              fallbackTrack.roleIds = Array.from(unique)
            }

            if (typeof parsed.nextPersonId !== 'number') parsed.nextPersonId = 1
            if (typeof parsed.nextTrackId !== 'number') parsed.nextTrackId = Math.max(
              1,
              ...parsed.tracks
                .map((track) => Number(String(track.id).replace(/[^0-9]/g, '')))
                .filter((value) => !Number.isNaN(value)),
            ) + 1
            if (typeof parsed.nextRoleId !== 'number') {
              const highestRoleNumber = parsed.roles
                .map((role) => Number(String(role.id).replace(/[^0-9]/g, '')))
                .filter((value) => !Number.isNaN(value))
                .reduce((max, value) => Math.max(max, value), 0)
              parsed.nextRoleId = highestRoleNumber + 1
            }
            if (typeof parsed.defaultTrackCapacity !== 'number' || parsed.defaultTrackCapacity < 1) {
              parsed.defaultTrackCapacity = 2
            }
            parsed.tenure = ensureTenureState(parsed.tenure)
            const trackIdSet = new Set(parsed.tracks.map((track) => track.id))
            const normalTrackIdSet = new Set(
              parsed.tracks.filter((track) => track.type === 'normal').map((track) => track.id),
            )
            const personIdSet = new Set(parsed.people.map((person) => person.id))
            Object.keys(parsed.tenure.assignments).forEach((personId) => {
              const info = parsed.tenure.assignments[personId]
              if (
                !info ||
                !trackIdSet.has(info.trackId) ||
                !normalTrackIdSet.has(info.trackId) ||
                !personIdSet.has(personId)
              ) {
                delete parsed.tenure.assignments[personId]
              }
            })
            Object.keys(parsed.tenure.overrides).forEach((trackId) => {
              if (!normalTrackIdSet.has(trackId)) {
                delete parsed.tenure.overrides[trackId]
              }
            })
            return parsed
          } catch (e) {
            console.warn('Failed to load planner state, resetting.', e)
            return createInitialState()
          }
        }

        function saveState() {
          try {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
          } catch (e) {
            console.warn('Failed to save planner state.', e)
          }
        }

        function getTrackByType(type) {
          return state.tracks.find((t) => t.type === type) || null
        }

        function getTrackById(id) {
          return state.tracks.find((t) => t.id === id) || null
        }

        function isTrackLocked(track) {
          return Boolean(track && track.type === 'normal' && track.locked)
        }

        function shouldAllowLockedTrackEdit(track, message) {
          if (!track || track.type !== 'normal') return false
          if (!isTrackLocked(track)) return true
          const promptMessage =
            typeof message === 'string' && message.trim().length
              ? message
              : `"${track.name}" is locked. Continue?`
          return window.confirm(promptMessage)
        }

        function getPersonById(id) {
          return state.people.find((p) => p.id === id) || null
        }

        function findPersonTrack(personId) {
          return (
            state.tracks.find(
              (track) => Array.isArray(track.personIds) && track.personIds.includes(personId),
            ) || null
          )
        }

        function getRoleById(id) {
          return state.roles.find((r) => r.id === id) || null
        }

        function findRoleTrack(roleId) {
          return state.tracks.find((track) => Array.isArray(track.roleIds) && track.roleIds.includes(roleId)) || null
        }

        function updatePersonName(personId, newName) {
          const person = getPersonById(personId)
          if (!person) return false
          const trimmed = newName.trim()
          if (!trimmed) return false
          const previousName = person.name
          if (trimmed === previousName) return false
          return mutateState(`Rename ${previousName} to ${trimmed}`, () => {
            person.name = trimmed
            return true
          })
        }

        function trackHasCapacity(track) {
          if (track.capacity == null) return true
          return track.personIds.length < track.capacity
        }

        function getNormalTracks() {
          return state.tracks.filter((track) => track.type === 'normal')
        }

        function generateAutomaticTrackName(counter = state.nextTrackId) {
          const letterIndex = counter
          if (letterIndex >= 1 && letterIndex <= 26) {
            return `Track ${String.fromCharCode(64 + letterIndex)}`
          }
          return `Track ${letterIndex}`
        }

        function setDropZoneActive(active) {
          const dropZone = document.getElementById('createTrackDropZone')
          if (!dropZone) return
          if (active) {
            dropZone.classList.add('visible')
            dropZone.setAttribute('aria-hidden', 'false')
          } else {
            dropZone.classList.remove('visible')
            dropZone.classList.remove('hover')
            dropZone.setAttribute('aria-hidden', 'true')
          }
        }

        function createNormalTrack({ name, capacity, personIds = [], roleIds = [] } = {}) {
          const trackNumber = state.nextTrackId++
          const track = {
            id: 'track-' + trackNumber,
            name: name || generateAutomaticTrackName(trackNumber),
            type: 'normal',
            capacity:
              capacity === null
                ? null
                : typeof capacity === 'number' && capacity >= 1
                  ? capacity
                  : state.defaultTrackCapacity,
            personIds: Array.isArray(personIds) ? [...personIds] : [],
            roleIds: Array.isArray(roleIds) ? [...roleIds] : [],
            locked: false,
          }
          state.tracks.push(track)
          if (track.personIds.length) {
            for (const personId of track.personIds) {
              recordTenureAssignment(personId, track)
            }
          }
          return track
        }

        function ensureNormalTrack(preferredTrackId) {
          if (preferredTrackId) {
            const preferred = getTrackById(preferredTrackId)
            if (preferred && preferred.type === 'normal') {
              return preferred
            }
          }
          const normalTracks = getNormalTracks()
          if (normalTracks.length) {
            return normalTracks[0]
          }
          return createNormalTrack()
        }

        function createTrackFromPersonDrop(personId) {
          const person = getPersonById(personId)
          if (!person) return false
          const sourceTrack = findPersonTrack(personId)
          if (sourceTrack && isTrackLocked(sourceTrack)) {
            const allowed = shouldAllowLockedTrackEdit(
              sourceTrack,
              `"${sourceTrack.name}" is locked. Remove ${person.name} to new track?`,
            )
            if (!allowed) return false
          }
          const description = `Create track for ${person.name}`
          return mutateState(description, () => {
            const sourceTrackInside = state.tracks.find((t) => t.personIds.includes(personId))
            if (sourceTrackInside) {
              sourceTrackInside.personIds = sourceTrackInside.personIds.filter((id) => id !== personId)
            }

            const newTrack = createNormalTrack({ capacity: null, personIds: [personId] })
            return Boolean(newTrack)
          })
        }

        function snapshotPlannerState(source = state) {
          return JSON.parse(JSON.stringify(source))
        }

        function getPlannerIdentifier() {
          if (typeof window === 'undefined' || !window.location) {
            return 'mobbist'
          }
          const { host, origin } = window.location
          if (host && host.trim()) {
            return host.trim()
          }
          if (origin && origin.trim() && origin !== 'null') {
            return origin.trim()
          }
          return 'mobbist'
        }

        function buildClipboardDeepLink() {
          if (typeof window === 'undefined' || !window.location) {
            return 'https://app.mobbist.dev/?load=clipboard'
          }
          try {
            const url = new URL(window.location.href)
            if (url.pathname.endsWith('/index.html')) {
              const trimmed = url.pathname.slice(0, -'/index.html'.length)
              url.pathname = trimmed || '/'
            }
            if (!url.pathname) {
              url.pathname = '/'
            }
            url.search = '?load=clipboard'
            url.hash = ''
            return url.toString()
          } catch (error) {
            console.warn('Failed to derive clipboard deep link, using default.', error)
            return 'https://app.mobbist.dev/?load=clipboard'
          }
        }

        function serializeClipboardFrontmatter(meta) {
          if (!meta || typeof meta !== 'object') {
            return ''
          }
          const entries = []
          for (const [rawKey, rawValue] of Object.entries(meta)) {
            const key = String(rawKey || '').trim()
            if (!key) continue
            const value = serializeClipboardFrontmatterValue(rawValue)
            if (value === null) continue
            entries.push(`${key}: ${value}`)
          }
          if (!entries.length) {
            return ''
          }
          return ['---', ...entries, '---'].join('\n')
        }

        function serializeClipboardFrontmatterValue(value) {
          if (value == null || value === '') {
            return null
          }
          if (typeof value === 'number') {
            if (!Number.isFinite(value)) return null
            return Number.isInteger(value) ? String(value) : String(value)
          }
          if (typeof value === 'boolean') {
            return value ? 'true' : 'false'
          }
          const stringValue = String(value)
          if (!stringValue.trim()) {
            return null
          }
          if (/^[A-Za-z0-9_.-]+$/.test(stringValue)) {
            return stringValue
          }
          return JSON.stringify(stringValue)
        }

        function parseClipboardFrontmatter(lines) {
          if (!Array.isArray(lines) || !lines.length) {
            return { meta: null, nextIndex: 0, hasFrontmatter: false }
          }
          let index = 0
          while (index < lines.length && !lines[index].trim()) {
            index++
          }
          if (index >= lines.length || lines[index].trim() !== '---') {
            return { meta: null, nextIndex: 0, hasFrontmatter: false }
          }
          index++
          const meta = {}
          let closed = false
          while (index < lines.length) {
            const rawLine = lines[index]
            const trimmed = rawLine.trim()
            if (trimmed === '---') {
              index++
              closed = true
              break
            }
            if (!trimmed || trimmed.startsWith('#')) {
              index++
              continue
            }
            const colonIndex = trimmed.indexOf(':')
            if (colonIndex === -1) {
              index++
              continue
            }
            const rawKey = trimmed.slice(0, colonIndex).trim().toLowerCase()
            let rawValue = trimmed.slice(colonIndex + 1).trim()
            if (!rawKey) {
              index++
              continue
            }
            let value
            if (/^(true|false)$/i.test(rawValue)) {
              value = rawValue.toLowerCase() === 'true'
            } else if (/^-?\d+(?:\.\d+)?$/.test(rawValue)) {
              value = Number(rawValue)
            } else if (rawValue.startsWith('"') && rawValue.endsWith('"') && rawValue.length >= 2) {
              try {
                value = JSON.parse(rawValue)
              } catch (parseError) {
                value = rawValue.slice(1, -1)
              }
            } else if (rawValue.startsWith("'") && rawValue.endsWith("'") && rawValue.length >= 2) {
              value = rawValue.slice(1, -1)
            } else {
              value = rawValue
            }
            const normalizedKey = rawKey.replace(/\s+/g, '_')
            const canonicalKey = normalizedKey.replace(/-/g, '_')
            meta[rawKey] = value
            meta[normalizedKey] = value
            meta[canonicalKey] = value
            index++
          }
          if (!closed) {
            return { meta: null, nextIndex: 0, hasFrontmatter: false }
          }
          return { meta, nextIndex: index, hasFrontmatter: true }
        }

        function serializePlannerStateToMarkdown(sourceState = state) {

          const snapshot = snapshotPlannerState(sourceState)
          const safeSnapshot =
            snapshot && typeof snapshot === 'object' ? snapshot : createInitialState()
          const tenureState = ensureTenureState(safeSnapshot.tenure)
          const lines = []
          const exportedAt = new Date().toISOString()
          const defaultCapacity =
            typeof safeSnapshot.defaultTrackCapacity === 'number' &&
            safeSnapshot.defaultTrackCapacity >= 1
              ? safeSnapshot.defaultTrackCapacity
              : 2
          const frontmatter = serializeClipboardFrontmatter({
            format: CLIPBOARD_FORMAT_ID,
            version: CLIPBOARD_FORMAT_VERSION,
            exported_at: exportedAt,
            planner: getPlannerIdentifier(),
            default_capacity: defaultCapacity,
            tenure_soft: tenureState.config.softDays,
            tenure_hard: tenureState.config.hardDays,
            people: Array.isArray(safeSnapshot.people) ? safeSnapshot.people.length : 0,
            tracks: Array.isArray(safeSnapshot.tracks) ? safeSnapshot.tracks.length : 0,
          })
          if (frontmatter) {
            lines.push(frontmatter)
            lines.push('')
          }
          lines.push('# Mobbist Board')
          const deepLink = buildClipboardDeepLink()
          if (deepLink) {
            lines.push('')
            lines.push(`[Open this board in Mobbist](${deepLink})`)
          }
          lines.push('')
          const peopleById = new Map((safeSnapshot.people || []).map((person) => [person.id, person]))
          const rolesById = new Map((safeSnapshot.roles || []).map((role) => [role.id, role]))
          const assignments = tenureState.assignments || {}
          const overrides = tenureState.overrides || {}
          for (const track of safeSnapshot.tracks || []) {
            const trackName =
              typeof track.name === 'string' && track.name.trim().length
                ? track.name.trim()
                : track.id
            const tokens = [
              { key: 'id', value: track.id },
              { key: 'type', value: track.type },
            ]
            if (track.capacity == null) {
              tokens.push({ key: 'capacity', value: 'unbounded' })
            } else {
              tokens.push({ key: 'capacity', value: track.capacity })
            }
            if (track.locked) {
              tokens.push({ key: 'locked' })
            }
            if (track.type === 'normal') {
              const override = overrides[track.id]
              if (override && override.softDays != null && override.hardDays != null) {
                tokens.push({ key: 'tenure_soft', value: override.softDays })
                tokens.push({ key: 'tenure_hard', value: override.hardDays })
              }
            }
            lines.push(`## ${trackName}${formatClipboardTokens(tokens)}`)
            const personIds = Array.isArray(track.personIds) ? track.personIds : []
            if (personIds.length) {
              for (const personId of personIds) {
                const person = peopleById.get(personId)
                if (!person) continue
                const personTokens = [{ key: 'id', value: person.id }]
                if (track.type === 'normal') {
                  const assignment = assignments[person.id]
                  if (
                    assignment &&
                    assignment.trackId === track.id &&
                    typeof assignment.assignedAt === 'number' &&
                    Number.isFinite(assignment.assignedAt)
                  ) {
                    personTokens.push({ key: 'tenure', value: assignment.assignedAt })
                  }
                }
                const personName =
                  typeof person.name === 'string' && person.name.trim().length
                    ? person.name.trim()
                    : person.id
                lines.push(`- ${personName}${formatClipboardTokens(personTokens)}`)
              }
            } else {
              lines.push('- (empty)')
            }
            if (track.type === 'normal') {
              const roleIds = Array.isArray(track.roleIds) ? track.roleIds : []
              if (roleIds.length) {
                lines.push('Roles:')
                for (const roleId of roleIds) {
                  const role = rolesById.get(roleId)
                  if (!role) continue
                  const roleTokens = [{ key: 'id', value: role.id }]
                  if (role.color) {
                    roleTokens.push({ key: 'color', value: role.color })
                  }
                  const roleName =
                    typeof role.name === 'string' && role.name.trim().length
                      ? role.name.trim()
                      : role.id
                  lines.push(`- ${roleName}${formatClipboardTokens(roleTokens)}`)
                }
              }
            }
            lines.push('')
          }
          return lines.join('\n').replace(/\n{3,}/g, '\n\n').trim()
        }

        function parsePlannerMarkdown(markdown, options = {}) {
          const source = typeof markdown === 'string' ? markdown : ''
          if (!source.trim()) {
            throw new Error('Clipboard data is empty.')
          }
          const normalized = source.replace(/\r\n/g, '\n')
          const rawLines = normalized.split('\n')
          const { meta: frontmatterMeta, nextIndex, hasFrontmatter } = parseClipboardFrontmatter(rawLines)
          const meta = frontmatterMeta ? { ...frontmatterMeta } : {}
          if (!hasFrontmatter) {
            console.info('Mobbist clipboard import: legacy metadata format detected (no frontmatter).')
          }
          const tracks = []
          let currentTrack = null
          let inMeta = false
          let inRoles = false
          const startIndex = nextIndex || 0

          function finalizeTrack() {
            if (currentTrack) {
              tracks.push(currentTrack)
              currentTrack = null
            }
          }

          for (let lineIndex = startIndex; lineIndex < rawLines.length; lineIndex++) {
            const rawLine = rawLines[lineIndex]
            const line = rawLine.trim()
            if (!line) {
              inRoles = false
              continue
            }
            if (line.startsWith('## ')) {
              const headingBody = line.slice(3).trim()
              const { text, tokens } = parseBracketTokens(headingBody)
              const headingName = text.trim()
              if (!headingName) continue
              if (headingName.toLowerCase() === 'meta') {
                finalizeTrack()
                inMeta = !hasFrontmatter
                inRoles = false
                continue
              }
              finalizeTrack()
              currentTrack = { name: headingName, tokens, people: [], roles: [] }
              inMeta = false
              inRoles = false
              continue
            }
            if (line.startsWith('#')) {
              continue
            }
            if (inMeta) {
              if (line.startsWith('- ')) {
                const metaLine = line.slice(2).trim()
                const colonIndex = metaLine.indexOf(':')
                if (colonIndex !== -1) {
                  const key = metaLine.slice(0, colonIndex).trim().toLowerCase()
                  const value = metaLine.slice(colonIndex + 1).trim()
                  if (key) {
                    meta[key] = value
                    const normalizedKey = key.replace(/\s+/g, '_')
                    const canonicalKey = normalizedKey.replace(/-/g, '_')
                    meta[normalizedKey] = value
                    meta[canonicalKey] = value
                  }
                }
              }
              continue
            }
            if (!currentTrack) {
              continue
            }
            if (/^roles\s*:/i.test(line)) {
              inRoles = true
              continue
            }
            if (!line.startsWith('- ')) {
              continue
            }
            const itemBody = line.slice(2).trim()
            if (!itemBody || itemBody.toLowerCase() === '(empty)') {
              continue
            }
            const { text, tokens } = parseBracketTokens(itemBody)
            if (!text) continue
            if (inRoles) {
              currentTrack.roles.push({ name: text, tokens })
            } else {
              currentTrack.people.push({ name: text, tokens })
            }
          }

          finalizeTrack()

          if (!meta.format) {
            throw new Error('Clipboard data missing format metadata.')
          }
          if (meta.format.trim().toLowerCase() !== CLIPBOARD_FORMAT_ID) {
            throw new Error(`Unsupported clipboard format: ${meta.format}`)
          }
          const versionValue = meta.version ? String(meta.version).trim() : CLIPBOARD_FORMAT_VERSION
          const major = Number(versionValue.split('.')[0])
          if (!Number.isFinite(major)) {
            throw new Error(`Invalid clipboard version: ${versionValue}`)
          }
          if (major > CLIPBOARD_SUPPORTED_MAJOR_VERSION) {
            throw new Error(`Clipboard version ${versionValue} is not supported.`)
          }

          const existingState = options.existingState || state
          const rebuiltState = buildStateFromParsedClipboard({ meta, tracks }, existingState)
          return {
            state: rebuiltState,
            meta: {
              exportedAt: meta.exported_at || meta['exported-at'] || null,
              version: versionValue,
            },
          }
        }

        function buildStateFromParsedClipboard(parsed, existingState) {
          const existing =
            existingState && typeof existingState === 'object' ? existingState : createInitialState()
          const newState = createInitialState()
          newState.people = []
          newState.roles = []
          newState.tracks = []
          newState.tenure = createInitialTenureState()
          newState.tenure.assignments = {}
          newState.tenure.overrides = {}

          const meta = parsed && parsed.meta ? parsed.meta : {}
          const tracksInput = parsed && Array.isArray(parsed.tracks) ? parsed.tracks : []

          const personMap = new Map()
          const roleMap = new Map()
          const onDeckTracks = []
          const outOfOfficeTracks = []
          const normalTracks = []

          const usedPersonIds = new Set()
          const usedRoleIds = new Set()
          const usedTrackIds = new Set()

          let generatedPersonCounter =
            typeof existing.nextPersonId === 'number' && existing.nextPersonId > 0
              ? existing.nextPersonId
              : 1
          let generatedRoleCounter =
            typeof existing.nextRoleId === 'number' && existing.nextRoleId > 0
              ? existing.nextRoleId
              : 1
          let generatedTrackCounter =
            typeof existing.nextTrackId === 'number' && existing.nextTrackId > 0
              ? existing.nextTrackId
              : 1

          function allocatePersonId(preferredId) {
            let id = preferredId && preferredId.trim().length ? preferredId.trim() : null
            if (id && usedPersonIds.has(id)) {
              id = null
            }
            if (!id) {
              while (true) {
                const candidate = 'p-' + generatedPersonCounter++
                if (!usedPersonIds.has(candidate)) {
                  id = candidate
                  break
                }
              }
            }
            usedPersonIds.add(id)
            return id
          }

          function allocateRoleId(preferredId) {
            let id = preferredId && preferredId.trim().length ? preferredId.trim() : null
            if (id && usedRoleIds.has(id)) {
              id = null
            }
            if (!id) {
              while (true) {
                const candidate = 'role-' + generatedRoleCounter++
                if (!usedRoleIds.has(candidate)) {
                  id = candidate
                  break
                }
              }
            }
            usedRoleIds.add(id)
            return id
          }

          function allocateTrackId(preferredId, type, name) {
            let id = preferredId && preferredId.trim().length ? preferredId.trim() : null
            if (type === 'on_deck') {
              id = 'on_deck'
            } else if (type === 'out_of_office') {
              id = 'out_of_office'
            }
            if (id && usedTrackIds.has(id)) {
              id = null
            }
            if (!id) {
              while (true) {
                const candidate = 'track-' + generatedTrackCounter++
                if (!usedTrackIds.has(candidate)) {
                  id = candidate
                  break
                }
              }
            }
            usedTrackIds.add(id)
            return id
          }

          function ensurePerson(entry) {
            if (!entry) return null
            const name = typeof entry.name === 'string' ? entry.name.trim() : ''
            const tokens = entry.tokens || {}
            const preferredId =
              tokens.id && typeof tokens.id === 'string' ? tokens.id.trim() : null
            const id = allocatePersonId(preferredId)
            let person = personMap.get(id)
            if (!person) {
              person = {
                id,
                name: name || id,
              }
              personMap.set(id, person)
            } else if (name) {
              person.name = name
            }
            return { id, tokens, person }
          }

          function ensureRole(entry) {
            if (!entry) return null
            const name = typeof entry.name === 'string' ? entry.name.trim() : ''
            const tokens = entry.tokens || {}
            const preferredId =
              tokens.id && typeof tokens.id === 'string' ? tokens.id.trim() : null
            const id = allocateRoleId(preferredId)
            let role = roleMap.get(id)
            if (!role) {
              role = {
                id,
                name: name || id,
                color: null,
              }
              roleMap.set(id, role)
            } else if (name) {
              role.name = name
            }
            if (typeof tokens.color === 'string' && tokens.color.trim().length) {
              role.color = tokens.color.trim()
            }
            return { id, role }
          }

          function determineTrackType(name, tokens) {
            const explicit =
              tokens && typeof tokens.type === 'string'
                ? tokens.type.trim().toLowerCase()
                : ''
            if (explicit === 'normal' || explicit === 'on_deck' || explicit === 'out_of_office') {
              return explicit
            }
            const tokenId =
              tokens && typeof tokens.id === 'string' ? tokens.id.trim().toLowerCase() : ''
            if (tokenId === 'on_deck') return 'on_deck'
            if (tokenId === 'out_of_office') return 'out_of_office'
            const normalized = name.trim().toLowerCase()
            if (normalized === 'on deck') return 'on_deck'
            if (normalized === 'out of office') return 'out_of_office'
            return 'normal'
          }

          const globalConfigInput = {}
          const metaSoftRaw = meta.tenure_soft ?? meta['tenure-soft']
          const metaHardRaw = meta.tenure_hard ?? meta['tenure-hard']
          const metaSoftNumber = Number(metaSoftRaw)
          const metaHardNumber = Number(metaHardRaw)
          if (Number.isFinite(metaSoftNumber) && metaSoftNumber > 0) {
            globalConfigInput.softDays = metaSoftNumber
          }
          if (Number.isFinite(metaHardNumber) && metaHardNumber > 0) {
            globalConfigInput.hardDays = metaHardNumber
          }
          newState.tenure.config = normalizeTenureThresholds(globalConfigInput)

          const defaultCapacityRaw =
            meta.default_capacity ??
            meta['default-capacity'] ??
            meta.capacity_default ??
            meta['capacity-default']
          const parsedDefaultCapacity = Number(defaultCapacityRaw)
          if (Number.isFinite(parsedDefaultCapacity) && parsedDefaultCapacity >= 1) {
            newState.defaultTrackCapacity = parsedDefaultCapacity
          } else if (
            typeof existing.defaultTrackCapacity === 'number' &&
            existing.defaultTrackCapacity >= 1
          ) {
            newState.defaultTrackCapacity = existing.defaultTrackCapacity
          } else {
            newState.defaultTrackCapacity = 2
          }

          for (const trackEntry of tracksInput) {
            const name =
              typeof trackEntry.name === 'string' && trackEntry.name.trim().length
                ? trackEntry.name.trim()
                : 'Untitled Track'
            const tokens = trackEntry.tokens || {}
            const type = determineTrackType(name, tokens)
            const preferredId =
              tokens.id && typeof tokens.id === 'string' ? tokens.id.trim() : null
            const trackId = allocateTrackId(preferredId, type, name)
            const track = {
              id: trackId,
              name,
              type,
              capacity: null,
              personIds: [],
              roleIds: [],
              locked: false,
            }

            const capacityToken =
              tokens.capacity != null ? String(tokens.capacity).trim().toLowerCase() : ''
            if (type === 'normal') {
              if (
                !capacityToken ||
                capacityToken === 'unbounded' ||
                capacityToken === 'none' ||
                capacityToken === 'null' ||
                capacityToken === 'infinite' ||
                capacityToken === '∞'
              ) {
                track.capacity = null
              } else {
                const capacityNumber = Number(capacityToken)
                track.capacity =
                  Number.isFinite(capacityNumber) && capacityNumber >= 1
                    ? capacityNumber
                    : newState.defaultTrackCapacity
              }
              if (tokens.locked === true) {
                track.locked = true
              } else if (typeof tokens.locked === 'string') {
                const value = tokens.locked.trim().toLowerCase()
                track.locked = value === 'true' || value === 'yes' || value === 'locked'
              }
            }

            for (const personEntry of trackEntry.people || []) {
              const ensured = ensurePerson(personEntry)
              if (!ensured) continue
              track.personIds.push(ensured.id)
              if (type === 'normal') {
                const tenureToken = ensured.tokens.tenure ?? ensured.tokens['tenure']
                const tenureNumber = tenureToken != null ? Number(tenureToken) : NaN
                if (Number.isFinite(tenureNumber) && tenureNumber > 0) {
                  newState.tenure.assignments[ensured.id] = {
                    trackId,
                    assignedAt: tenureNumber,
                  }
                }
              }
            }

            if (type === 'normal') {
              const overrideSoftToken = tokens.tenure_soft ?? tokens['tenure-soft']
              const overrideHardToken = tokens.tenure_hard ?? tokens['tenure-hard']
              const overrideInput = {}
              const overrideSoftNumber =
                overrideSoftToken != null ? Number(overrideSoftToken) : NaN
              const overrideHardNumber =
                overrideHardToken != null ? Number(overrideHardToken) : NaN
              if (Number.isFinite(overrideSoftNumber) && overrideSoftNumber > 0) {
                overrideInput.softDays = overrideSoftNumber
              }
              if (Number.isFinite(overrideHardNumber) && overrideHardNumber > 0) {
                overrideInput.hardDays = overrideHardNumber
              }
              if (Object.keys(overrideInput).length) {
                const normalizedOverride = normalizeTenureOverride(
                  overrideInput,
                  newState.tenure.config,
                )
                if (normalizedOverride.softDays && normalizedOverride.hardDays) {
                  newState.tenure.overrides[trackId] = normalizedOverride
                }
              }
              for (const roleEntry of trackEntry.roles || []) {
                const ensuredRole = ensureRole(roleEntry)
                if (!ensuredRole) continue
                if (!track.roleIds.includes(ensuredRole.id)) {
                  track.roleIds.push(ensuredRole.id)
                }
              }
            }

            if (type === 'on_deck') {
              onDeckTracks.push(track)
            } else if (type === 'out_of_office') {
              outOfOfficeTracks.push(track)
            } else {
              normalTracks.push(track)
            }
          }

          if (!onDeckTracks.length) {
            const id = allocateTrackId('on_deck', 'on_deck', 'On Deck')
            onDeckTracks.push({
              id,
              name: 'On Deck',
              type: 'on_deck',
              capacity: null,
              personIds: [],
              roleIds: [],
              locked: false,
            })
          }
          if (!outOfOfficeTracks.length) {
            const id = allocateTrackId('out_of_office', 'out_of_office', 'Out of Office')
            outOfOfficeTracks.push({
              id,
              name: 'Out of Office',
              type: 'out_of_office',
              capacity: null,
              personIds: [],
              roleIds: [],
              locked: false,
            })
          }
          if (!normalTracks.length) {
            const id = allocateTrackId(null, 'normal', 'Track A')
            normalTracks.push({
              id,
              name: 'Track A',
              type: 'normal',
              capacity: newState.defaultTrackCapacity,
              personIds: [],
              roleIds: [],
              locked: false,
            })
          }

          newState.tracks = [...onDeckTracks, ...outOfOfficeTracks, ...normalTracks]
          newState.people = Array.from(personMap.values())
          newState.roles = Array.from(roleMap.values())

          const validPersonIds = new Set(newState.people.map((person) => person.id))
          const normalTrackIds = new Set(normalTracks.map((track) => track.id))
          Object.keys(newState.tenure.assignments).forEach((personId) => {
            const info = newState.tenure.assignments[personId]
            if (!info || !validPersonIds.has(personId) || !normalTrackIds.has(info.trackId)) {
              delete newState.tenure.assignments[personId]
            }
          })
          Object.keys(newState.tenure.overrides).forEach((trackId) => {
            if (!normalTrackIds.has(trackId)) {
              delete newState.tenure.overrides[trackId]
            }
          })

          let maxPersonNumber = 0
          for (const person of newState.people) {
            const match = /^p-(\d+)$/.exec(person.id)
            if (match) {
              const value = Number(match[1])
              if (value > maxPersonNumber) {
                maxPersonNumber = value
              }
            }
          }
          let maxRoleNumber = 0
          for (const role of newState.roles) {
            const match = /^role-(\d+)$/.exec(role.id)
            if (match) {
              const value = Number(match[1])
              if (value > maxRoleNumber) {
                maxRoleNumber = value
              }
            }
          }
          let maxTrackNumber = 0
          for (const track of newState.tracks) {
            const match = /^track-(\d+)$/.exec(track.id)
            if (match) {
              const value = Number(match[1])
              if (value > maxTrackNumber) {
                maxTrackNumber = value
              }
            }
          }

          const existingNextPerson =
            typeof existing.nextPersonId === 'number' && existing.nextPersonId > 0
              ? existing.nextPersonId
              : 1
          const existingNextRole =
            typeof existing.nextRoleId === 'number' && existing.nextRoleId > 0
              ? existing.nextRoleId
              : 1
          const existingNextTrack =
            typeof existing.nextTrackId === 'number' && existing.nextTrackId > 0
              ? existing.nextTrackId
              : 1

          newState.nextPersonId = Math.max(
            existingNextPerson,
            generatedPersonCounter,
            maxPersonNumber + 1,
            1,
          )
          newState.nextRoleId = Math.max(
            existingNextRole,
            generatedRoleCounter,
            maxRoleNumber + 1,
            1,
          )
          newState.nextTrackId = Math.max(
            existingNextTrack,
            generatedTrackCounter,
            maxTrackNumber + 1,
            1,
          )

          return newState
        }

        function buildTrackAssignments(snapshot) {
          const assignments = new Map()
          snapshot.tracks.forEach((track) => {
            track.personIds.forEach((personId, index) => {
              assignments.set(personId, { trackId: track.id, index })
            })
          })
          return assignments
        }

        function shouldAnimatePerson(personId) {
          if (!pendingAnimatedPersonIds) return true
          return pendingAnimatedPersonIds.has(personId)
        }

        function announceHistory(message) {
          if (!message) return
          pendingHistoryAnnouncement = message
        }

        function mutateState(description, mutator) {
          pendingAnimatedPersonIds = null
          const previousPositions = capturePersonPositions()
          const previousState = snapshotPlannerState()
          const previousSerialized = JSON.stringify(previousState)
          const result = mutator()
          if (result === false) return false
          const nextSerialized = JSON.stringify(state)
          if (previousSerialized === nextSerialized) {
            return result
          }
          const prevAssignments = buildTrackAssignments(previousState)
          const nextAssignments = buildTrackAssignments(state)
          const animatedIds = new Set()
          prevAssignments.forEach((info, personId) => {
            const nextInfo = nextAssignments.get(personId)
            if (!nextInfo || nextInfo.trackId !== info.trackId) {
              animatedIds.add(personId)
            }
          })
          nextAssignments.forEach((info, personId) => {
            if (!prevAssignments.has(personId)) {
              animatedIds.add(personId)
            }
          })
          pendingAnimatedPersonIds = animatedIds.size ? animatedIds : null
          pendingAnimationPositions = previousPositions
          undoStack.push({ description, state: previousState })
          if (undoStack.length > HISTORY_LIMIT) {
            undoStack.shift()
          }
          redoStack = []
          announceHistory(`${description}. Undo available.`)
          saveState()
          dirtySinceServerLoad = true
          render()
          return result
        }



        function updateHistoryControls() {
          if (!undoButtonEl || !redoButtonEl) return
          const undoEntry = undoStack[undoStack.length - 1] || null
          const redoEntry = redoStack[redoStack.length - 1] || null
          undoButtonEl.disabled = !undoEntry
          redoButtonEl.disabled = !redoEntry
          undoButtonEl.textContent = undoEntry ? `Undo ${undoEntry.description}` : 'Undo'
          redoButtonEl.textContent = redoEntry ? `Redo ${redoEntry.description}` : 'Redo'
          undoButtonEl.setAttribute('aria-disabled', undoButtonEl.disabled ? 'true' : 'false')
          redoButtonEl.setAttribute('aria-disabled', redoButtonEl.disabled ? 'true' : 'false')

        }

        function capturePersonPositions() {
          const positions = {}
          const peopleEls = document.querySelectorAll('.person')
          peopleEls.forEach((el) => {
            const personId = el.dataset.personId
            if (!personId) return
            const rect = el.getBoundingClientRect()
            const nameEl = el.querySelector('.person-name')
            const label = nameEl ? nameEl.textContent?.trim() || '' : el.textContent?.trim() || ''
            const listEl = el.closest('.people-list')
            const trackId = listEl ? listEl.dataset.trackId || null : null
            const peers = listEl ? Array.from(listEl.querySelectorAll('.person')) : []
            const index = peers.indexOf(el)
            positions[personId] = {
              left: rect.left,
              top: rect.top,
              width: rect.width,
              height: rect.height,
              label,
              trackId,
              index,
            }
          })
          return positions
        }

        function spawnHistoryGhost(prev, options = {}) {
          const overlay = ensureHistoryOverlay()
          if (!overlay) return
          const {
            deltaX = 0,
            deltaY = 0,
            finalOpacity = 0,
            label = prev.label || '',
            duration = 600,
          } = options
          const ghost = document.createElement('div')
          ghost.className = 'history-ghost'
          ghost.textContent = label
          ghost.style.position = 'absolute'
          ghost.style.left = `${prev.left}px`
          ghost.style.top = `${prev.top}px`
          ghost.style.width = `${prev.width}px`
          ghost.style.height = `${prev.height}px`
          ghost.style.transform = 'translate(0, 0)'
          ghost.style.opacity = '1'
          overlay.appendChild(ghost)
          requestAnimationFrame(() => {
            ghost.style.transition = `transform ${duration}ms ease, opacity ${duration}ms ease`
            ghost.style.transform = `translate(${deltaX}px, ${deltaY}px)`
            ghost.style.opacity = `${finalOpacity}`
          })
          ghost.addEventListener(
            'transitionend',
            () => {
              ghost.remove()
            },
            { once: true },
          )
          window.setTimeout(() => {
            if (ghost.isConnected) {
              ghost.remove()
            }
          }, duration + 120)
        }

        function highlightPersonArrival(el) {
          el.classList.add('history-flash')
          el.addEventListener(
            'animationend',
            () => {
              el.classList.remove('history-flash')
            },
            { once: true },
          )
        }

        function playPendingAnimation() {
          if (!pendingAnimationPositions) {
            pendingAnimatedPersonIds = null
            return
          }
          const previous = pendingAnimationPositions
          pendingAnimationPositions = null
          const reduceMotion =
            window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches
          if (reduceMotion) {
            pendingAnimatedPersonIds = null
            return
          }

          const overlay = ensureHistoryOverlay()
          if (overlay) {
            overlay.innerHTML = ''
          }

          const handled = new Set()
          const peopleEls = document.querySelectorAll('.person')
          peopleEls.forEach((el) => {
            const personId = el.dataset.personId
            if (!personId) return
            const rect = el.getBoundingClientRect()
            const prev = previous[personId]
            if (!prev) {
              if (shouldAnimatePerson(personId)) {
                highlightPersonArrival(el)
              }
              return
            }
            handled.add(personId)
            const listEl = el.closest('.people-list')
            const currentTrackId = listEl ? listEl.dataset.trackId || null : null
            const peers = listEl ? Array.from(listEl.querySelectorAll('.person')) : []
            const currentIndex = peers.indexOf(el)
            const prevTrackId = Object.prototype.hasOwnProperty.call(prev, 'trackId') ? prev.trackId : null
            const prevIndex = typeof prev.index === 'number' ? prev.index : -1
            const trackChanged = prevTrackId !== currentTrackId
            const indexChanged = prevIndex !== currentIndex
            if (trackChanged || indexChanged) {
              if (!shouldAnimatePerson(personId)) {
                return
              }
              const deltaX = rect.left - prev.left
              const deltaY = rect.top - prev.top
              spawnHistoryGhost(prev, {
                deltaX,
                deltaY,
                label: prev.label,
              })
              highlightPersonArrival(el)
            }
          })

          Object.keys(previous).forEach((personId) => {
            if (handled.has(personId)) return
            const prev = previous[personId]
            if (!prev) return
            if (!shouldAnimatePerson(personId)) return
            spawnHistoryGhost(prev, {
              deltaX: 0,
              deltaY: -24,
              label: prev.label,
            })
          })
          pendingAnimatedPersonIds = null
        }

        function flushHistoryAnnouncement() {
          if (!historyAnnouncerEl || !pendingHistoryAnnouncement) return
          historyAnnouncerEl.textContent = pendingHistoryAnnouncement
          pendingHistoryAnnouncement = ''
        }

        function applyStateSnapshot(snapshot) {
          state = snapshotPlannerState(snapshot)
          if (!state.tenure) {
            state.tenure = createInitialTenureState()
          } else {
            state.tenure = ensureTenureState(state.tenure)
          }
          const normalTrackIds = new Set(
            state.tracks.filter((track) => track.type === 'normal').map((track) => track.id),
          )
          Object.keys(state.tenure.overrides).forEach((trackId) => {
            if (!normalTrackIds.has(trackId)) {
              delete state.tenure.overrides[trackId]
            }
          })
          selectedTrackIds = new Set()
          pendingRetirePersonId = null
        }


        function clearObsoleteTrackSelections() {
          const existingIds = new Set(
            state.tracks.filter((t) => t.type === 'normal').map((t) => t.id),
          )
          selectedTrackIds = new Set(
            [...selectedTrackIds].filter((id) => existingIds.has(id)),
          )
        }

        function undoLastAction() {
          if (!undoStack.length) return
          const previousPositions = capturePersonPositions()
          const entry = undoStack.pop()
          const currentSnapshot = snapshotPlannerState()
          redoStack.push({ description: entry.description, state: currentSnapshot })
          if (redoStack.length > HISTORY_LIMIT) {
            redoStack.shift()
          }
          applyStateSnapshot(entry.state)
          pendingAnimationPositions = previousPositions
          announceHistory(`Undid ${entry.description}`)
          saveState()
          render()
        }

        function redoLastAction() {
          if (!redoStack.length) return
          const previousPositions = capturePersonPositions()
          const entry = redoStack.pop()
          const currentSnapshot = snapshotPlannerState()
          undoStack.push({ description: entry.description, state: currentSnapshot })
          if (undoStack.length > HISTORY_LIMIT) {
            undoStack.shift()
          }
          applyStateSnapshot(entry.state)
          pendingAnimationPositions = previousPositions
          announceHistory(`Redid ${entry.description}`)
          saveState()
          render()
        }

        function handleHistoryShortcut(ev) {
          if (ev.defaultPrevented) return
          const key = typeof ev.key === 'string' ? ev.key.toLowerCase() : ''
          const isUndoShortcut = (ev.metaKey || ev.ctrlKey) && key === 'z' && !ev.altKey && !ev.shiftKey
          const isRedoShortcut =
            ((ev.metaKey || ev.ctrlKey) && key === 'z' && ev.shiftKey && !ev.altKey) ||
            (ev.ctrlKey && !ev.metaKey && key === 'y' && !ev.altKey && !ev.shiftKey)

          if (!isUndoShortcut && !isRedoShortcut) return

          const target = ev.target
          if (target) {
            const tag = target.tagName
            const isEditable =
              target.isContentEditable ||
              tag === 'INPUT' ||
              tag === 'TEXTAREA'
            if (isEditable) {
              return
            }
          }

          ev.preventDefault()
          if (isUndoShortcut) {
            undoLastAction()
          } else if (isRedoShortcut) {
            redoLastAction()
          }
        }

        function getDefaultTrackCapacity() {
          if (!state || typeof state.defaultTrackCapacity !== 'number') return 2
          if (state.defaultTrackCapacity < 1) return 1
          return state.defaultTrackCapacity
        }

        function addPeopleFromTextarea() {
          const textarea = document.getElementById('bulkNamesInput')
          if (!textarea) return
          const value = textarea.value || ''
          const lines = value
            .split(/\n+/)
            .map((l) => l.trim())
            .filter(Boolean)
          if (!lines.length) {
            alert('Please enter at least one name.')
            return
          }

          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          const description =
            lines.length === 1 ? `Add ${lines[0]}` : `Add ${lines.length} people`

          mutateState(description, () => {
            for (const name of lines) {
              const person = {
                id: 'p-' + state.nextPersonId++,
                name,
              }
              state.people.push(person)
              onDeck.personIds.push(person.id)
            }
            return true
          })

          textarea.value = ''
        }

        function resetPlan() {
          mutateState('Reset plan', () => {
            state = createInitialState()
            selectedTrackIds = new Set()
            currentDragPersonId = null
            currentDragRoleId = null
            pendingRetirePersonId = null
            return true
          })
        }

        async function exportBoardToClipboard() {
          const markdown = serializePlannerStateToMarkdown()
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
          const fileName = `mobbist-board-${timestamp}.md`
          const clipboard = typeof navigator !== 'undefined' ? navigator.clipboard : null
          if (clipboard && typeof clipboard.writeText === 'function') {
            try {
              await clipboard.writeText(markdown)
              alert('Board copied to clipboard as Markdown.')
              return
            } catch (error) {
              console.warn('Clipboard write failed; falling back to download.', error)
            }
          }
          try {
            const blob = new Blob([markdown], { type: 'text/markdown' })
            const url = URL.createObjectURL(blob)
            const link = document.createElement('a')
            link.href = url
            link.download = fileName
            document.body.appendChild(link)
            link.click()
            document.body.removeChild(link)
            URL.revokeObjectURL(url)
            alert('Clipboard unavailable. Downloaded Markdown file instead.')
          } catch (downloadError) {
            console.error('Failed to export board markdown.', downloadError)
            alert('Failed to export board Markdown. See console for details.')
          }
        }

        function applyImportedBoardState(parsed, options = {}) {
          const { notify = 'alert', description: overrideDescription } = options || {}
          const notifyMode = typeof notify === 'string' ? notify : 'alert'
          if (!parsed || !parsed.state) {
            if (notifyMode === 'alert') {
              alert('Import failed: No board data provided.')
            } else {
              console.warn('Import failed: No board data provided.')
            }
            return false
          }
          const description =
            typeof overrideDescription === 'string' && overrideDescription.trim().length
              ? overrideDescription.trim()
              : 'Import board from Markdown'
          const applied = mutateState(description, () => {
            applyStateSnapshot(parsed.state)
            return true
          })
          if (applied === false) {
            if (notifyMode === 'alert') {
              alert('Import skipped: board unchanged.')
            } else {
              console.info('Import skipped: board unchanged.')
            }
            return false
          }
          const exportedAt = parsed.meta && parsed.meta.exportedAt ? parsed.meta.exportedAt : null
          if (notifyMode === 'alert') {
            if (exportedAt) {
              alert(`Board imported from Markdown snapshot created ${exportedAt}.`)
            } else {
              alert('Board imported from Markdown.')
            }
          }
          return true
        }

        function handleBoardImportText(rawText) {
          const text = (rawText || '').trim()
          if (!text) {
            alert('Import cancelled: no Markdown provided.')
            return
          }
          let parsed
          try {
            parsed = parsePlannerMarkdown(text, { existingState: state })
          } catch (error) {
            console.error('Failed to parse board markdown.', error)
            alert(`Import failed: ${error.message || error}`)
            return
          }
          const confirmMessage =
            'Importing will replace the current board with the clipboard snapshot. Continue?'
          if (!window.confirm(confirmMessage)) {
            return
          }
          applyImportedBoardState(parsed)
        }

        async function importBoardFromClipboard() {
          let text = ''
          const clipboard = typeof navigator !== 'undefined' ? navigator.clipboard : null
          if (clipboard && typeof clipboard.readText === 'function') {
            try {
              text = await clipboard.readText()
            } catch (error) {
              console.warn('Clipboard read failed; falling back to manual paste.', error)
            }
          }
          if (!text || !text.trim()) {
            text = window.prompt('Paste board Markdown to import:') || ''
          }
          handleBoardImportText(text)
        }

        async function maybeAutoLoadClipboardFromQuery() {
          if (typeof window === 'undefined') {
            return
          }
          if (clipboardAutoLoadAttempted) {
            return
          }
          let search = ''
          try {
            search = window.location.search || ''
          } catch (error) {
            console.warn('Unable to read query parameters for clipboard autoload.', error)
            return
          }
          let loadParam = ''
          try {
            const params = new URLSearchParams(search)
            loadParam = params.get('load') || ''
          } catch (error) {
            console.warn('Failed to parse query parameters for clipboard autoload.', error)
            return
          }
          if (!loadParam || loadParam.trim().toLowerCase() !== 'clipboard') {
            return
          }
          clipboardAutoLoadAttempted = true
          const clipboard = typeof navigator !== 'undefined' ? navigator.clipboard : null
          if (!clipboard || typeof clipboard.readText !== 'function') {
            alert('Automatic clipboard import is unavailable. Use "Import board from clipboard" instead.')
            return
          }
          let text = ''
          try {
            text = await clipboard.readText()
          } catch (error) {
            console.warn('Automatic clipboard import failed to read clipboard.', error)
            alert('Unable to read clipboard automatically. Grant clipboard access and try again.')
            return
          }
          if (!text || !text.trim()) {
            alert('Clipboard is empty or does not contain a Mobbist export. Copy an export and refresh to import automatically.')
            return
          }
          let parsed
          try {
            parsed = parsePlannerMarkdown(text, { existingState: state })
          } catch (error) {
            console.warn('Automatic clipboard import failed to parse data.', error)
            alert(`Unable to load board from clipboard: ${error.message || error}`)
            return
          }
          const exportedAtRaw = parsed.meta && parsed.meta.exportedAt ? parsed.meta.exportedAt : null
          const exportedAt =
            typeof exportedAtRaw === 'string' ? exportedAtRaw.trim() : exportedAtRaw
          const description =
            typeof exportedAt === 'string' && exportedAt.length
              ? `Auto-import board from ${exportedAt}`
              : 'Auto-import board from clipboard'
          const applied = applyImportedBoardState(parsed, { notify: 'history', description })
          if (!applied) {
            alert('Clipboard import skipped because no changes were detected.')
          }
        }

        function handlePlannerPaste(event) {
          if (!event || !event.clipboardData) return
          const target = event.target
          if (
            target &&
            (target.isContentEditable ||
              (target.tagName &&
                (target.tagName.toLowerCase() === 'input' || target.tagName.toLowerCase() === 'textarea')))
          ) {
            return
          }
          const text = event.clipboardData.getData('text/plain')
          if (!text || !text.trim()) return
          let parsed
          try {
            parsed = parsePlannerMarkdown(text, { existingState: state })
          } catch (error) {
            return
          }
          const confirmMessage =
            'Import board state from clipboard? This replaces the current board.'
          if (!window.confirm(confirmMessage)) {
            return
          }
          event.preventDefault()
          event.stopPropagation()
          applyImportedBoardState(parsed)
        }

        function quickAddCapacityTrack(extraSlots) {
          const defaultCapacity = getDefaultTrackCapacity()
          let remaining = Math.max(defaultCapacity, extraSlots || defaultCapacity)
          const createdTrackIds = []

          while (remaining > 0) {
            const trackNumber = state.nextTrackId++
            const track = {
              id: 'track-' + trackNumber,
              name: `Extra Track ${trackNumber}`,
              type: 'normal',
              capacity: defaultCapacity,
              personIds: [],
              roleIds: [],
              locked: false,
            }
            state.tracks.push(track)
            createdTrackIds.push(track.id)
            remaining -= defaultCapacity
          }

          return createdTrackIds
        }

        function movePersonToTrackInternal(personId, targetTrackId) {
          const person = getPersonById(personId)
          const target = getTrackById(targetTrackId)
          if (!person || !target) return false
          if (!trackHasCapacity(target) && !target.personIds.includes(personId)) {
            return false
          }

          for (const track of state.tracks) {
            const idx = track.personIds.indexOf(personId)
            if (idx !== -1) {
              track.personIds.splice(idx, 1)
              break
            }
          }

          if (!target.personIds.includes(personId)) {
            target.personIds.push(personId)
          }

          if (target.type === 'normal') {
            recordTenureAssignment(personId, target)
          } else {
            clearPersonTenure(personId)
          }

          return true
        }

        function attachDragEvents(element) {
          if (!element) return
          element.draggable = false
        }

        function movePersonToTrack(personId, targetTrackId, options = {}) {
          const person = getPersonById(personId)
          const target = getTrackById(targetTrackId)
          if (!person || !target) return false
          const ignoreLocks = Boolean(options.ignoreLocks)
          const sourceTrack = findPersonTrack(personId)

          if (!ignoreLocks) {
            const confirmations = []

            if (sourceTrack && sourceTrack.id !== target.id && isTrackLocked(sourceTrack)) {
              confirmations.push(
                `"${sourceTrack.name}" is locked. Remove ${person.name}?`,
              )
            }

            if (target && (!sourceTrack || sourceTrack.id !== target.id) && isTrackLocked(target)) {
              confirmations.push(`"${target.name}" is locked. Add ${person.name}?`)
            }

            let nextCapacity = null
            const willChangeCapacity =
              target.type === 'normal' &&
              target.capacity != null &&
              (!sourceTrack || sourceTrack.id !== target.id) &&
              target.personIds.length >= target.capacity
            if (willChangeCapacity) {
              nextCapacity = target.personIds.length + 1
              confirmations.push(
                `"${target.name}" is full. Increase capacity to ${nextCapacity}?`,
              )
            }

            if (confirmations.length) {
              const message = confirmations.join('\n')
              const allowed = window.confirm(message)
              if (!allowed) return false
            }

            if (willChangeCapacity && nextCapacity != null) {
              const updated = updateTrackCapacity(target.id, nextCapacity)
              if (!updated) return false
            }
          }

          const description =
            options.description || `Move ${person.name} to ${target.name}`
          return mutateState(description, () =>
            movePersonToTrackInternal(personId, targetTrackId),
          )
        }

        function updateRoleName(roleId, newName) {
          const role = getRoleById(roleId)
          if (!role) return false
          const trimmed = newName.trim()
          if (!trimmed || trimmed === role.name) return false
          return mutateState(`Rename role ${role.name} to ${trimmed}`, () => {
            role.name = trimmed
            return true
          })
        }

        function moveRoleToTrackInternal(roleId, targetTrackId) {
          const role = getRoleById(roleId)
          const target = getTrackById(targetTrackId)
          if (!role || !target || target.type !== 'normal') return false
          const currentTrack = findRoleTrack(roleId)
          if (currentTrack && currentTrack.id === targetTrackId) {
            return false
          }
          if (currentTrack) {
            currentTrack.roleIds = currentTrack.roleIds.filter((id) => id !== roleId)
          }
          if (!target.roleIds.includes(roleId)) {
            target.roleIds.push(roleId)
          }
          return true
        }

        function moveRoleToTrack(roleId, targetTrackId, options = {}) {
          const role = getRoleById(roleId)
          const target = getTrackById(targetTrackId)
          if (!role || !target || target.type !== 'normal') return false
          const ignoreLocks = Boolean(options.ignoreLocks)
          const sourceTrack = findRoleTrack(roleId)

          if (!ignoreLocks) {
            const confirmations = []

            if (sourceTrack && sourceTrack.id !== target.id && isTrackLocked(sourceTrack)) {
              confirmations.push(
                `"${sourceTrack.name}" is locked. Remove role ${role.name}?`,
              )
            }

            if (target && (!sourceTrack || sourceTrack.id !== target.id) && isTrackLocked(target)) {
              confirmations.push(`"${target.name}" is locked. Add role ${role.name}?`)
            }

            if (confirmations.length) {
              const message = confirmations.join('\n')
              const allowed = window.confirm(message)
              if (!allowed) return false
            }
          }

          const description =
            options.description || `Move role ${role.name} to ${target.name}`
          return mutateState(description, () =>
            moveRoleToTrackInternal(roleId, targetTrackId),
          )
        }

        function createRole({ name, color = null, targetTrackId } = {}) {
          const trimmed = (name || '').trim()
          if (!trimmed) return false
          const normalizedColor = color && color.trim() ? color.trim() : null
          return mutateState(`Add role ${trimmed}`, () => {
            const role = {
              id: 'role-' + state.nextRoleId++,
              name: trimmed,
              color: normalizedColor,
            }
            state.roles.push(role)
            const destination = ensureNormalTrack(targetTrackId)
            if (destination) {
              if (!destination.roleIds.includes(role.id)) {
                destination.roleIds.push(role.id)
              }
            }
            return true
          })
        }

        function deleteRole(roleId) {
          const role = getRoleById(roleId)
          if (!role) return false
          const lockedTrack = state.tracks.find(
            (track) =>
              track.type === 'normal' &&
              isTrackLocked(track) &&
              Array.isArray(track.roleIds) &&
              track.roleIds.includes(roleId),
          )
          if (lockedTrack) {
            const allowed = shouldAllowLockedTrackEdit(
              lockedTrack,
              `"${lockedTrack.name}" is locked. Remove role ${role.name}?`,
            )
            if (!allowed) return false
          }
          return mutateState(`Delete role ${role.name}`, () => {
            state.roles = state.roles.filter((r) => r.id !== roleId)
            for (const track of state.tracks) {
              if (Array.isArray(track.roleIds) && track.roleIds.includes(roleId)) {
                track.roleIds = track.roleIds.filter((id) => id !== roleId)
              }
            }
            return true
          })
        }

        function shuffleRole(roleId) {
          const role = getRoleById(roleId)
          if (!role) return false
          return mutateState(`Shuffle role ${role.name}`, () => {
            const currentTrack = findRoleTrack(roleId)
            if (currentTrack && isTrackLocked(currentTrack)) return false
            const candidates = getNormalTracks().filter((track) => {
              if (currentTrack && track.id === currentTrack.id) return false
              if (isTrackLocked(track)) return false
              return true
            })
            if (!candidates.length) return false
            const target = candidates[Math.floor(Math.random() * candidates.length)]
            return moveRoleToTrackInternal(roleId, target.id)
          })
        }

        function shuffleAllRoles() {
          if (!state.roles.length) return false
          return mutateState('Shuffle all roles', () => {
            const normalTracks = getNormalTracks()
            if (!normalTracks.length) return false

            const lockedTracks = normalTracks.filter((track) => isTrackLocked(track))
            const unlockedTracks = normalTracks.filter((track) => !isTrackLocked(track))
            if (!unlockedTracks.length) return false

            const lockedRoleIds = new Set()
            lockedTracks.forEach((track) => {
              track.roleIds.forEach((roleId) => lockedRoleIds.add(roleId))
            })

            const pool = state.roles
              .map((role) => role.id)
              .filter((roleId) => !lockedRoleIds.has(roleId))

            if (pool.length <= 1 && unlockedTracks.length <= 1) {
              return false
            }

            const previousAssignments = unlockedTracks.map((track) => [...track.roleIds])
            const shuffled = [...pool]
            for (let i = shuffled.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1))
              ;[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]
            }

            unlockedTracks.forEach((track) => {
              track.roleIds = []
            })

            shuffled.forEach((roleId, index) => {
              const target = unlockedTracks[index % unlockedTracks.length]
              target.roleIds.push(roleId)
            })

            const changed = unlockedTracks.some((track, index) => {
              const previous = previousAssignments[index] || []
              if (previous.length !== track.roleIds.length) return true
              return previous.some((id, idx) => id !== track.roleIds[idx])
            })
            return changed
          })
        }

        function sweepTrackKeepOneInternal(track, onDeck, ignoreLock = false) {
          if (!track) return false
          if (!onDeck) return false
          if (track.type === 'on_deck') return false
          if (isTrackLocked(track) && !ignoreLock) return false
          if (track.personIds.length <= 1) return false

          const idxToKeep = Math.floor(Math.random() * track.personIds.length)
          const keepId = track.personIds[idxToKeep]
          const toMove = track.personIds.filter((id) => id !== keepId)

          track.personIds = [keepId]
          onDeck.personIds.push(...toMove)
          if (toMove.length) {
            for (const personId of toMove) {
              clearPersonTenure(personId)
            }
          }

          return true
        }

        function sweepTrackKeepOne(trackId) {
          const track = getTrackById(trackId)
          const onDeck = getTrackByType('on_deck')
          if (!track || !onDeck) return false
          if (isTrackLocked(track)) {
            const allowed = shouldAllowLockedTrackEdit(
              track,
              `"${track.name}" is locked. Sweep everyone but one?`,
            )
            if (!allowed) return false
            const description = `Sweep ${track.name} (keep one)`
            return mutateState(description, () => sweepTrackKeepOneInternal(track, onDeck, true))
          }
          const description = `Sweep ${track.name} (keep one)`
          return mutateState(description, () => sweepTrackKeepOneInternal(track, onDeck))
        }

        function sweepAllTracksKeepOne() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false
          return mutateState('Sweep all tracks (keep one)', () => {
            let changed = false
            for (const track of state.tracks) {
              if (track.type !== 'normal') continue
              if (isTrackLocked(track)) continue
              if (sweepTrackKeepOneInternal(track, onDeck)) {
                changed = true
              }
            }
            return changed
          })
        }

        function sweepAndAllocateFromOnDeck() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck || !onDeck.personIds.length) return false

          return mutateState('Allocate from On Deck', () => {
            let normalTracks = state.tracks.filter((t) => t.type === 'normal')
            let changed = false

            if (!normalTracks.length) {
              const createdIds = quickAddCapacityTrack(onDeck.personIds.length)
              if (createdIds.length) {
                changed = true
                normalTracks = state.tracks.filter((t) => t.type === 'normal')
              }
            }

            let unlockedTracks = normalTracks.filter((track) => !isTrackLocked(track))

            if (!unlockedTracks.length) {
              const createdIds = quickAddCapacityTrack(onDeck.personIds.length)
              if (createdIds.length) {
                changed = true
                normalTracks = state.tracks.filter((t) => t.type === 'normal')
                unlockedTracks = normalTracks.filter((track) => !isTrackLocked(track))
              }
            }

            if (!unlockedTracks.length) return changed

            const onDeckCount = onDeck.personIds.length
            let totalAvailableSlots = 0
            let hasInfiniteCapacity = false
            for (const track of unlockedTracks) {
              if (track.capacity == null) {
                hasInfiniteCapacity = true
                break
              }
              const available = Math.max(0, track.capacity - track.personIds.length)
              totalAvailableSlots += available
            }

            if (!hasInfiniteCapacity && onDeckCount > 0 && totalAvailableSlots < onDeckCount) {
              const shortage = onDeckCount - totalAvailableSlots
              const createdIds = quickAddCapacityTrack(shortage)
              if (createdIds.length) {
                changed = true
                normalTracks = state.tracks.filter((t) => t.type === 'normal')
                unlockedTracks = normalTracks.filter((track) => !isTrackLocked(track))
              }
            }

            if (!unlockedTracks.length) return changed

            const remaining = onDeck.personIds.slice()
            for (let i = remaining.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1))
              ;[remaining[i], remaining[j]] = [remaining[j], remaining[i]]
            }

            const originalOnDeckCount = onDeck.personIds.length
            for (const track of unlockedTracks) {
              if (!remaining.length) break
              const capacity = track.capacity == null ? Infinity : track.capacity
              let availableSlots = capacity - track.personIds.length
              while (availableSlots > 0 && remaining.length) {
                 const id = remaining.pop()
                 if (!id) break
                 track.personIds.push(id)
                 recordTenureAssignment(id, track)
                 availableSlots--
                 changed = true

              }
            }

            if (remaining.length !== originalOnDeckCount) {
              onDeck.personIds = remaining
              changed = true
            }

            return changed
          })
        }

        function deleteTrack(trackId) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false
          if (isTrackLocked(track)) {
            const allowed = shouldAllowLockedTrackEdit(
              track,
              `"${track.name}" is locked. Delete this track?`,
            )
            if (!allowed) return false
          }
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false
          const description = `Delete track ${track.name}`
          return mutateState(description, () => {
             const rolesToReassign = Array.isArray(track.roleIds) ? [...track.roleIds] : []
             let fallback = state.tracks.find((t) => t.type === 'normal' && t.id !== trackId)
             if (!fallback && rolesToReassign.length) {
               fallback = createNormalTrack()
             }
             if (fallback && rolesToReassign.length) {
               for (const roleId of rolesToReassign) {
                 if (!fallback.roleIds.includes(roleId)) {
                   fallback.roleIds.push(roleId)
                 }
               }
             }
              if (track.personIds.length) {
                for (const personId of track.personIds) {
                  clearPersonTenure(personId)
                }
              }
              clearTrackTenureOverride(track.id)
              onDeck.personIds.push(...track.personIds)
              state.tracks = state.tracks.filter((t) => t.id !== trackId)
              selectedTrackIds.delete(trackId)
              return true


          })
        }

        function deleteAllTracks() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false

          const normalTracks = state.tracks.filter((t) => t.type === 'normal')
          if (!normalTracks.length) return false

          const deletableTracks = normalTracks.filter((track) => !isTrackLocked(track))
          if (!deletableTracks.length) return false

          const description =
            deletableTracks.length === normalTracks.length
              ? `Delete all ${deletableTracks.length} track(s)`
              : `Delete ${deletableTracks.length} unlocked track(s)`

          return mutateState(description, () => {
             const rolesToReassign = []
             for (const track of deletableTracks) {
               if (track.personIds.length) {
                 for (const personId of track.personIds) {
                   clearPersonTenure(personId)
                 }
               }
               clearTrackTenureOverride(track.id)
               onDeck.personIds.push(...track.personIds)
               if (Array.isArray(track.roleIds) && track.roleIds.length) {
                 rolesToReassign.push(...track.roleIds)
               }
             }


            const deletableIds = new Set(deletableTracks.map((track) => track.id))
            state.tracks = state.tracks.filter(
              (t) => !(t.type === 'normal' && deletableIds.has(t.id)),
            )

            for (const id of Array.from(selectedTrackIds)) {
              if (deletableIds.has(id)) {
                selectedTrackIds.delete(id)
              }
            }

            if (rolesToReassign.length) {
              createNormalTrack({ roleIds: Array.from(new Set(rolesToReassign)) })
            }

            return true
          })
        }

        function deleteSelectedTracks() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false

          const tracksToDelete = state.tracks.filter(
            (t) => t.type === 'normal' && selectedTrackIds.has(t.id),
          )
          if (!tracksToDelete.length) return false

          const lockedTracks = tracksToDelete.filter((track) => isTrackLocked(track))
          for (const track of lockedTracks) {
            const allowed = shouldAllowLockedTrackEdit(
              track,
              `"${track.name}" is locked. Delete this track?`,
            )
            if (!allowed) return false
          }

          const description =
            tracksToDelete.length === 1
              ? `Delete track ${tracksToDelete[0].name}`
              : `Delete ${tracksToDelete.length} selected tracks`

          return mutateState(description, () => {
             const rolesToReassign = []
             for (const track of tracksToDelete) {
               if (track.personIds.length) {
                 for (const personId of track.personIds) {
                   clearPersonTenure(personId)
                 }
               }
               clearTrackTenureOverride(track.id)
               onDeck.personIds.push(...track.personIds)
               if (Array.isArray(track.roleIds) && track.roleIds.length) {
                 rolesToReassign.push(...track.roleIds)
               }
             }


            state.tracks = state.tracks.filter(
              (t) => !(t.type === 'normal' && selectedTrackIds.has(t.id)),
            )
            selectedTrackIds.clear()

            if (rolesToReassign.length) {
              let fallback = state.tracks.find((t) => t.type === 'normal')
              if (!fallback) {
                fallback = createNormalTrack()
              }
              if (fallback) {
                const uniqueRoleIds = new Set(fallback.roleIds)
                for (const roleId of rolesToReassign) {
                  if (!uniqueRoleIds.has(roleId)) {
                    fallback.roleIds.push(roleId)
                    uniqueRoleIds.add(roleId)
                  }
                }
              }
            }

            return true
          })
        }

        function updateTrackCapacity(trackId, newCapacity) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false

          if (isTrackLocked(track)) {
            const allowed = shouldAllowLockedTrackEdit(
              track,
              newCapacity == null
                ? `"${track.name}" is locked. Make capacity unlimited?`
                : `"${track.name}" is locked. Set capacity to ${newCapacity}?`,
            )
            if (!allowed) return false
          }

          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false

          if (newCapacity != null && newCapacity < 1) {
            alert('Capacity must be at least 1.')
            return false
          }

          const description =
            newCapacity == null
              ? `Make ${track.name} capacity unlimited`
              : `Set ${track.name} capacity to ${newCapacity}`

          return mutateState(description, () => {
            let changed = false

            if (newCapacity == null) {
              if (track.capacity !== null) {
                track.capacity = null
                changed = true
              }
              return changed
            }

            if (track.capacity !== newCapacity) {
              track.capacity = newCapacity
              changed = true
            }

            if (track.personIds.length > newCapacity) {
              const overflow = track.personIds.splice(newCapacity)
              if (overflow.length) {
                for (const personId of overflow) {
                  clearPersonTenure(personId)
                }
                onDeck.personIds.push(...overflow)
                changed = true
              }
            }

            return changed
          })
        }

        function promptTrackTenureOverride(trackId) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false
          ensureTenureContainer()
          const override = getTrackTenureOverride(trackId)
          const globalSoft = formatTenureThresholdValue(state.tenure.config.softDays)
          const globalHard = formatTenureThresholdValue(state.tenure.config.hardDays)
          const softDefault = override ? formatTenureThresholdValue(override.softDays) : ''
          const hardDefault = override ? formatTenureThresholdValue(override.hardDays) : ''
          const softPrompt = window.prompt(
            `Soft warning threshold (days) for "${track.name}". Leave blank to inherit global (${globalSoft}).`,
            softDefault,
          )
          if (softPrompt === null) return false
          const hardPrompt = window.prompt(
            `Strong warning threshold (days) for "${track.name}". Leave blank to inherit global (${globalHard}).`,
            hardDefault,
          )
          if (hardPrompt === null) return false
          const softValue = softPrompt.trim() === '' ? null : Number(softPrompt)
          const hardValue = hardPrompt.trim() === '' ? null : Number(hardPrompt)
          if (softValue != null && (!Number.isFinite(softValue) || softValue <= 0)) {
            alert('Soft warning threshold must be a positive number.')
            return false
          }
          if (hardValue != null && (!Number.isFinite(hardValue) || hardValue <= 0)) {
            alert('Strong warning threshold must be a positive number.')
            return false
          }
          const description =
            softValue == null && hardValue == null
              ? `Clear tenure override for ${track.name}`
              : `Set tenure override for ${track.name}`
          return mutateState(description, () => updateTrackTenureOverride(trackId, softValue, hardValue))
        }

        function updateTrackName(trackId, newName) {

          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false
          const trimmed = newName.trim()
          if (!trimmed || trimmed === track.name) return false
          const description = `Rename track to ${trimmed}`
          return mutateState(description, () => {
            track.name = trimmed
            return true
          })
        }

        function setTrackLocked(trackId, locked) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false
          if (Boolean(track.locked) === Boolean(locked)) return false
          const description = locked ? `Lock ${track.name}` : `Unlock ${track.name}`
          return mutateState(description, () => {
            track.locked = Boolean(locked)
            return true
          })
        }

        function sweepPerson(personId) {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return
          movePersonToTrack(personId, onDeck.id)
        }

        function shufflePerson(personId) {
          const person = getPersonById(personId)
          if (!person) return false
          return mutateState(`Shuffle ${person.name}`, () => {
            const currentTrack = state.tracks.find((t) => t.personIds.includes(personId))
            if (!currentTrack) return false
            if (isTrackLocked(currentTrack)) return false

            let candidates = state.tracks.filter((t) => {
              if (t.id === currentTrack.id) return false
              if (t.type === 'out_of_office') return false
              if (t.type === 'on_deck') return false
              if (isTrackLocked(t)) return false
              return trackHasCapacity(t)
            })

            let changed = false

            if (!candidates.length) {
              const created = quickAddCapacityTrack(1)
              if (created.length) {
                changed = true
              }
              candidates = state.tracks.filter((t) => {
                if (t.id === currentTrack.id) return false
                if (t.type === 'out_of_office') return false
                if (t.type === 'on_deck') return false
                if (isTrackLocked(t)) return false
                return trackHasCapacity(t)
              })
            }

            if (!candidates.length) {
              return changed
            }

            const idx = Math.floor(Math.random() * candidates.length)
            const target = candidates[idx]
            if (movePersonToTrackInternal(personId, target.id)) {
              changed = true
            }
            return changed
          })
        }

        function retirePerson(personId) {
          const person = getPersonById(personId)
          if (!person) return false
          const sourceTrack = findPersonTrack(personId)
          if (sourceTrack && isTrackLocked(sourceTrack)) {
            const allowed = shouldAllowLockedTrackEdit(
              sourceTrack,
              `"${sourceTrack.name}" is locked. Retire ${person.name}?`,
            )
            if (!allowed) return false
          }
          return mutateState(`Retire ${person.name}`, () => {
            const originalCount = state.people.length
            state.people = state.people.filter((p) => p.id !== personId)
            if (state.people.length === originalCount) {
              return false
            }
             for (const track of state.tracks) {
               track.personIds = track.personIds.filter((id) => id !== personId)
             }
             clearPersonTenure(personId)
             pendingRetirePersonId = null

            return true
          })
        }

        function onDragStartPerson(ev, personId) {
          currentDragPersonId = personId
          if (ev?.currentTarget instanceof HTMLElement) {
            currentDragPersonEl = ev.currentTarget
            currentDragPersonEl.classList.add('person-dragging')
          } else {
            currentDragPersonEl = null
          }
          if (ev && ev.target && ev.target.closest('.person-tenure-indicator')) {
            suppressTenureIndicatorClickUntil = Date.now() + 400
          } else {
            suppressTenureIndicatorClickUntil = 0
          }
          if (ev && ev.dataTransfer) {
            try {
              ev.dataTransfer.effectAllowed = 'move'
              ev.dataTransfer.dropEffect = 'move'
              ev.dataTransfer.setData('text/plain', personId)
              ev.dataTransfer.setData('application/x-mobbist-person-id', personId)
            } catch (error) {}
          }
          requestAnimationFrame(() => {
            setDropZoneActive(true)
          })


        }

        function onDragEndPerson(ev) {
          if (currentDragPersonEl) {
            currentDragPersonEl.classList.remove('person-dragging')
            currentDragPersonEl = null
          }
          currentDragPersonId = null
          const lists = document.querySelectorAll('.people-list')
          lists.forEach((el) => {
            clearListDropTarget(el)
          })
          setDropZoneActive(false)
        }

        function decorateListDropTarget(el, track, options = {}, dataTransfer) {
          if (!el) return
          const { isLockedTarget = false, isFullTarget = false } = options
          el.classList.add('drop-target')

          if (isLockedTarget) {
            el.classList.add('drop-target-locked')
          } else {
            el.classList.remove('drop-target-locked')
          }

          if (isFullTarget) {
            el.classList.add('drop-target-full')
          } else {
            el.classList.remove('drop-target-full')
          }

          const trackContainer = el.closest('.track')
          if (trackContainer) {
            trackContainer.classList.add('track-drop-target')
            if (isLockedTarget) {
              trackContainer.classList.add('track-drop-target-locked')
            } else {
              trackContainer.classList.remove('track-drop-target-locked')
            }
            if (isFullTarget) {
              trackContainer.classList.add('track-drop-target-full')
            } else {
              trackContainer.classList.remove('track-drop-target-full')
            }
          }

          if (dataTransfer) {
            dataTransfer.dropEffect = 'move'
          }
        }

        function clearListDropTarget(el) {
          if (!el) return
          el.classList.remove('drop-target')
          el.classList.remove('drop-target-locked')
          el.classList.remove('drop-target-full')
          const trackContainer = el.closest('.track')
          if (trackContainer) {
            trackContainer.classList.remove('track-drop-target')
            trackContainer.classList.remove('track-drop-target-locked')
            trackContainer.classList.remove('track-drop-target-full')
          }
        }

        function onDragEnterList(ev, trackId) {
          if (!currentDragPersonId) return
          const track = getTrackById(trackId)
          if (!track) return

          ev.preventDefault()

          const sourceTrack = findPersonTrack(currentDragPersonId)
          const isSameTrack = Boolean(sourceTrack && sourceTrack.id === track.id)
          const isLockedTarget = !isSameTrack && isTrackLocked(track)
          const hasCapacity = trackHasCapacity(track)
          const isFullTarget =
            !isSameTrack && track.type === 'normal' && track.capacity != null && !hasCapacity

          decorateListDropTarget(
            ev.currentTarget,
            track,
            { isLockedTarget, isFullTarget },
            ev.dataTransfer,
          )
        }

        function onDragOverList(ev, trackId) {
          if (!currentDragPersonId) return
          const track = getTrackById(trackId)
          if (!track) return

          ev.preventDefault()

          const sourceTrack = findPersonTrack(currentDragPersonId)
          const isSameTrack = Boolean(sourceTrack && sourceTrack.id === track.id)
          const isLockedTarget = !isSameTrack && isTrackLocked(track)
          const hasCapacity = trackHasCapacity(track)
          const isFullTarget =
            !isSameTrack && track.type === 'normal' && track.capacity != null && !hasCapacity

          decorateListDropTarget(
            ev.currentTarget,
            track,
            { isLockedTarget, isFullTarget },
            ev.dataTransfer,
          )
        }

        function onDragLeaveList(ev) {
          const el = ev.currentTarget
          clearListDropTarget(el)
        }

        function onDropOnList(ev, trackId) {
          ev.preventDefault()
          const el = ev.currentTarget
          clearListDropTarget(el)

          const personId = currentDragPersonId
          if (!personId) {
            return
          }

          currentDragPersonId = null
          setDropZoneActive(false)

          movePersonToTrack(personId, trackId)
        }

        function onDragEnterDropZone(ev) {
          if (!currentDragPersonId) return
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.add('hover')
          if (ev.dataTransfer) {
            ev.dataTransfer.dropEffect = 'move'
          }
        }

        function onDragOverDropZone(ev) {
          if (!currentDragPersonId) return
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.add('hover')
          if (ev.dataTransfer) {
            ev.dataTransfer.dropEffect = 'move'
          }
        }

        function onDragLeaveDropZone(ev) {
          const el = ev.currentTarget
          el.classList.remove('hover')
        }

        function onDropOnDropZone(ev) {
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.remove('hover')
          if (!currentDragPersonId) return
          const personId = currentDragPersonId
          currentDragPersonId = null
          createTrackFromPersonDrop(personId)
          setDropZoneActive(false)
        }

        function onGlobalDragOver(ev) {
          if (!currentDragPersonId && !currentDragRoleId) return
          ev.preventDefault()
          if (ev.dataTransfer) {
            ev.dataTransfer.dropEffect = 'move'
          }
        }

        function onGlobalDrop(ev) {
          if (!currentDragPersonId && !currentDragRoleId) return
          ev.preventDefault()
        }

        function onDragStartRole(ev, roleId) {
          currentDragRoleId = roleId
          if (ev.dataTransfer) {
            ev.dataTransfer.effectAllowed = 'move'
          }
        }

        function onDragEndRole() {
          currentDragRoleId = null
          const lists = document.querySelectorAll('.roles-list')
          lists.forEach((el) => {
            clearListDropTarget(el)
          })
        }

        function onDragEnterRolesList(ev, trackId) {
          if (!currentDragRoleId) return
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return

          ev.preventDefault()

          const isLockedTarget = isTrackLocked(track)

          decorateListDropTarget(
            ev.currentTarget,
            track,
            { isLockedTarget, isFullTarget: false },
            ev.dataTransfer,
          )
        }

        function onDragOverRolesList(ev, trackId) {
          if (!currentDragRoleId) return
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return

          ev.preventDefault()

          const isLockedTarget = isTrackLocked(track)

          decorateListDropTarget(
            ev.currentTarget,
            track,
            { isLockedTarget, isFullTarget: false },
            ev.dataTransfer,
          )
        }

        function onDragLeaveRolesList(ev) {
          const el = ev.currentTarget
          clearListDropTarget(el)
        }

        function onDropOnRolesList(ev, trackId) {
          ev.preventDefault()
          const el = ev.currentTarget
          clearListDropTarget(el)
          if (!currentDragRoleId) return
          moveRoleToTrack(currentDragRoleId, trackId)
          currentDragRoleId = null
        }

        function render() {
          const container = document.getElementById('tracksContainer')
          if (!container) return
          clearObsoleteTrackSelections()
          container.innerHTML = ''

          const defaultCapacityInput = document.getElementById('defaultCapacityInput')
          if (defaultCapacityInput) {
            defaultCapacityInput.value = String(getDefaultTrackCapacity())
          }

          const tenureSoftInput = document.getElementById('tenureSoftInput')
          const tenureHardInput = document.getElementById('tenureHardInput')
          if (tenureSoftInput && tenureHardInput) {
            ensureTenureContainer()
            const thresholds = state.tenure.config
            tenureSoftInput.value = formatTenureThresholdValue(thresholds.softDays)
            tenureHardInput.value = formatTenureThresholdValue(thresholds.hardDays)
          }

          const deleteSelectedTracksButton = document.getElementById('deleteSelectedTracksButton')
          if (deleteSelectedTracksButton) {
            const hasSelected = Array.from(selectedTrackIds).some((id) => {
              const t = getTrackById(id)
              return t && t.type === 'normal'
            })
            deleteSelectedTracksButton.disabled = !hasSelected
          }

          const sweepAllTracksButton = document.getElementById('sweepAllTracksButton')
          if (sweepAllTracksButton) {
            const canSweepAny = state.tracks.some(
              (t) => t.type === 'normal' && t.personIds.length > 1,
            )
            sweepAllTracksButton.disabled = !canSweepAny
          }

          const deleteAllTracksButton = document.getElementById('deleteAllTracksButton')
          if (deleteAllTracksButton) {
            const hasAnyNormalTrack = state.tracks.some((t) => t.type === 'normal')
            deleteAllTracksButton.disabled = !hasAnyNormalTrack
          }

          const sortTenureButton = document.getElementById('sortTenureButton')
          if (sortTenureButton) {
            const anySortable = state.tracks.some(
              (track) => track.type === 'normal' && track.personIds.length > 1,
            )
            sortTenureButton.disabled = !anySortable
          }

          const listStrongTenureButton = document.getElementById('listStrongTenureButton')
          if (listStrongTenureButton) {
            listStrongTenureButton.disabled = false
            const hasAlerts = hasStrongTenureBreaches()
            if (hasAlerts) {
              listStrongTenureButton.classList.add('primary')
              listStrongTenureButton.classList.remove('ghost')
            } else {
              listStrongTenureButton.classList.remove('primary')
              if (!listStrongTenureButton.classList.contains('ghost')) {
                listStrongTenureButton.classList.add('ghost')
              }
            }
            listStrongTenureButton.title = hasAlerts
              ? 'Strong alerts present. Click to list them.'
              : 'No strong alerts. Click to confirm.'
          }

          const shuffleRolesButton = document.getElementById('shuffleRolesButton')
          if (shuffleRolesButton) {
            const hasRoles = state.roles.length > 0
            const hasNormalTrack = state.tracks.some((t) => t.type === 'normal')
            shuffleRolesButton.disabled = !(hasRoles && hasNormalTrack)
          }

          const capacityNotice = document.getElementById('capacityNotice')
          if (capacityNotice) {
            capacityNotice.innerHTML = ''
            const normalTracks = state.tracks.filter((t) => t.type === 'normal')
            const anyHasCapacity = normalTracks.some((t) => trackHasCapacity(t))
            const onDeck = getTrackByType('on_deck')
            const onDeckCount = onDeck ? onDeck.personIds.length : 0

            let totalAvailableSlots = 0
            let hasInfiniteCapacity = false
            for (const track of normalTracks) {
              if (track.capacity == null) {
                hasInfiniteCapacity = true
                break
              }
              const available = Math.max(0, track.capacity - track.personIds.length)
              totalAvailableSlots += available
            }

            let shortage = 0
            if (!hasInfiniteCapacity && onDeckCount > 0 && totalAvailableSlots < onDeckCount) {
              shortage = onDeckCount - totalAvailableSlots
            }

            if (shortage > 0) {
              const text = document.createElement('span')
              const defaultCap = getDefaultTrackCapacity()
              text.textContent = `Not enough track capacity: ${onDeckCount} on deck but only ${totalAvailableSlots} open slot${totalAvailableSlots === 1 ? '' : 's'}. Allocating will automatically create extra tracks (capacity ${defaultCap}) until everyone fits.`
              capacityNotice.appendChild(text)
            } else if (normalTracks.length && !anyHasCapacity) {
              const text = document.createElement('span')
              text.textContent =
                'All tracks are at capacity; shuffle and drag are disabled until space is freed.'
              capacityNotice.appendChild(text)
            }
          }

          for (const track of state.tracks) {
            const trackEl = document.createElement('section')
            trackEl.className = 'track'
            if (track.locked) {
              trackEl.classList.add('track-locked')
            }
            trackEl.dataset.trackId = track.id
            trackEl.dataset.locked = track.locked ? 'true' : 'false'

            const header = document.createElement('div')
            header.className = 'track-header'

            const headerRow = document.createElement('div')
            headerRow.className = 'track-header-row'

            if (track.type === 'normal') {
              const selectCheckbox = document.createElement('input')
              selectCheckbox.type = 'checkbox'
              selectCheckbox.className = 'track-select-checkbox'
              selectCheckbox.checked = selectedTrackIds.has(track.id)
              selectCheckbox.title = 'Select track for batch delete'
              selectCheckbox.addEventListener('change', (ev) => {
                if (ev.target.checked) {
                  selectedTrackIds.add(track.id)
                } else {
                  selectedTrackIds.delete(track.id)
                }
                render()
              })
              headerRow.appendChild(selectCheckbox)
            }

            const titleSpan = document.createElement('span')
            titleSpan.className = 'track-title'
            titleSpan.textContent = track.name
            titleSpan.style.flex = '1'

            if (track.type === 'normal') {
              titleSpan.style.cursor = 'pointer'
              titleSpan.title = 'Click to rename track'
              titleSpan.addEventListener('click', () => {
                const nextName = prompt('New track name?', track.name)
                if (nextName == null) return
                const trimmed = nextName.trim()
                if (!trimmed || trimmed === track.name) return
                if (isTrackLocked(track)) {
                  const allowed = shouldAllowLockedTrackEdit(
                    track,
                    `"${track.name}" is locked. Rename this track?`,
                  )
                  if (!allowed) return
                }
                updateTrackName(track.id, trimmed)
              })
            }

            headerRow.appendChild(titleSpan)

            if (track.type === 'normal') {
              const lockButton = document.createElement('button')
              lockButton.type = 'button'
              lockButton.className = 'track-lock-toggle'
              lockButton.dataset.locked = track.locked ? 'true' : 'false'
              lockButton.setAttribute('aria-pressed', track.locked ? 'true' : 'false')
              lockButton.textContent = track.locked ? '🔓 Unlock' : '🔒 Lock'
              lockButton.title = track.locked
                ? 'Unlock this lane so global actions include it'
                : 'Lock this lane to skip global actions'
              lockButton.addEventListener('click', (ev) => {
                ev.preventDefault()
                setTrackLocked(track.id, !track.locked)
              })
              headerRow.appendChild(lockButton)
            }

            if (track.type !== 'normal') {
              const badge = document.createElement('span')
              badge.className = 'badge'
              const dot = document.createElement('span')
              dot.className = 'badge-dot'
              badge.appendChild(dot)
              const label = document.createElement('span')
              label.textContent = track.type === 'on_deck' ? 'On Deck' : 'Out of Office'
              badge.appendChild(label)
              headerRow.appendChild(badge)
            }

            header.appendChild(headerRow)

            const metaRow = document.createElement('div')
            metaRow.className = 'track-meta'

            const countSpan = document.createElement('span')
            const assigned = track.personIds.length
            const capacityLabel =
              track.capacity == null ? '∞' : String(track.capacity)
            countSpan.textContent =
              track.capacity == null
                ? `${assigned} assigned`
                : `${assigned} / ${capacityLabel} assigned`
            metaRow.appendChild(countSpan)

            if (track.type === 'normal') {
               const rolesCountSpan = document.createElement('span')
               const roleCount = track.roleIds.length
               rolesCountSpan.textContent = `${roleCount} role${roleCount === 1 ? '' : 's'}`
               metaRow.appendChild(rolesCountSpan)

               if (track.locked) {
                 const lockedBadge = document.createElement('span')
                 lockedBadge.className = 'badge badge-locked'
                 lockedBadge.textContent = 'Locked'
                 metaRow.appendChild(lockedBadge)
               }
             }

             const isFull =

              track.type === 'normal' &&
              track.capacity != null &&
              assigned >= track.capacity

            if (track.type === 'normal') {
              const capWrapper = document.createElement('div')
              const capLabel = document.createElement('span')
              capLabel.textContent = 'Capacity: '
              capLabel.className = 'muted'
              const capInput = document.createElement('input')
              capInput.type = 'number'
              capInput.min = '1'
              capInput.className = 'capacity-input'
              if (track.capacity != null) {
                capInput.value = String(track.capacity)
              } else {
                capInput.value = ''
              }
              capInput.placeholder = '∞'
              capInput.addEventListener('change', (ev) => {
                const value = ev.target.value.trim()
                if (!value) {
                  updateTrackCapacity(track.id, null)
                } else {
                  const parsed = Number(value)
                  if (Number.isNaN(parsed)) {
                    render()
                  } else {
                    updateTrackCapacity(track.id, parsed)
                  }
                }
              })
              capWrapper.appendChild(capLabel)
              capWrapper.appendChild(capInput)
              metaRow.appendChild(capWrapper)

              const tenureButton = document.createElement('button')
              tenureButton.type = 'button'
              tenureButton.className = 'tenure-config-button'
              const tenureThresholds = getEffectiveTenureThresholds(track.id)
              const tenureSoftLabel = formatTenureThresholdValue(tenureThresholds.softDays)
              const tenureHardLabel = formatTenureThresholdValue(tenureThresholds.hardDays)
              const overriddenTenure = hasTrackTenureOverride(track.id)
              tenureButton.dataset.overridden = overriddenTenure ? 'true' : 'false'
              tenureButton.textContent = `Tenure ${tenureSoftLabel}/${tenureHardLabel}d`
              tenureButton.title = overriddenTenure
                ? `Custom tenure thresholds for ${track.name}. Click to adjust or clear.`
                : `Using global tenure thresholds. Click to override for ${track.name}.`
              tenureButton.addEventListener('click', () => {
                promptTrackTenureOverride(track.id)
              })
              metaRow.appendChild(tenureButton)

              if (isFull) {
                const fullLabel = document.createElement('span')
                fullLabel.className = 'track-type'
                fullLabel.textContent = 'Full'
                metaRow.appendChild(fullLabel)
                trackEl.classList.add('track-full')
              }
            } else {
              const typeLabel = document.createElement('span')
              typeLabel.className = 'track-type'
              typeLabel.textContent =
                track.type === 'on_deck' ? 'Source pool' : 'Unavailable'
              metaRow.appendChild(typeLabel)
            }

            header.appendChild(metaRow)

            const actionsRow = document.createElement('div')
            actionsRow.className = 'track-actions'

            if (track.type === 'on_deck') {
              const sweepAllocBtn = document.createElement('button')
              sweepAllocBtn.textContent = 'Allocate to tracks'
              sweepAllocBtn.className = 'primary'
              sweepAllocBtn.disabled = !track.personIds.length
              sweepAllocBtn.addEventListener('click', () => {
                sweepAndAllocateFromOnDeck()
              })
              actionsRow.appendChild(sweepAllocBtn)
            } else if (track.type === 'normal') {
              actionsRow.style.display = 'flex'
              actionsRow.style.justifyContent = 'space-between'
              actionsRow.style.alignItems = 'center'
              actionsRow.style.gap = '8px'
              actionsRow.style.flexWrap = 'wrap'

              const leftActions = document.createElement('div')
              leftActions.style.display = 'flex'
              leftActions.style.flex = '1'
              leftActions.style.gap = '6px'
              leftActions.style.flexWrap = 'wrap'

              const sweepBtn = document.createElement('button')
              sweepBtn.textContent = '⬅️ Sweep (keep one)'
              sweepBtn.title = 'Sweep everyone but one back to On Deck'
              sweepBtn.className = 'primary'
              sweepBtn.addEventListener('click', () => {
                sweepTrackKeepOne(track.id)
              })
              sweepBtn.disabled = track.personIds.length <= 1
              leftActions.appendChild(sweepBtn)

              actionsRow.appendChild(leftActions)

              const deleteBtn = document.createElement('button')
              deleteBtn.textContent = 'Delete track'
              deleteBtn.className = 'danger'
              deleteBtn.addEventListener('click', () => {
                deleteTrack(track.id)
              })
              actionsRow.appendChild(deleteBtn)
            }

            header.appendChild(actionsRow)

            trackEl.appendChild(header)

            const peopleList = document.createElement('div')
            peopleList.className =
              'people-list' + (track.personIds.length ? '' : ' empty')
            peopleList.dataset.trackId = track.id
            peopleList.addEventListener('dragenter', (ev) =>
              onDragEnterList(ev, track.id),
            )
            peopleList.addEventListener('dragover', (ev) =>
              onDragOverList(ev, track.id),
            )
            peopleList.addEventListener('dragleave', onDragLeaveList)
            peopleList.addEventListener('drop', (ev) =>
              onDropOnList(ev, track.id),
            )

            if (!track.personIds.length) {
              const empty = document.createElement('span')
              empty.className = 'muted'
              empty.textContent = 'Empty'
              peopleList.appendChild(empty)
            } else {
              for (const personId of track.personIds) {
                const person = getPersonById(personId)
                if (!person) continue
                const personEl = document.createElement('div')
                personEl.className = 'person'
                personEl.dataset.personId = person.id
                personEl.draggable = true
                personEl.addEventListener('dragstart', (ev) =>
                  onDragStartPerson(ev, person.id),
                )
                personEl.addEventListener('dragend', onDragEndPerson)

                const nameSpan = document.createElement('span')
                nameSpan.className = 'person-name'
                nameSpan.textContent = person.name
                nameSpan.style.cursor = 'pointer'
                nameSpan.title = 'Click to rename person'
                nameSpan.draggable = false
                nameSpan.addEventListener('click', () => {
                  const newName = prompt('New name?', person.name)
                  if (!newName) return
                  updatePersonName(person.id, newName)
                })

                const nameContainer = document.createElement('div')
                nameContainer.className = 'person-header'
                nameContainer.appendChild(nameSpan)

                let tenureIndicatorButton = null
                if (track.type === 'normal') {
                  const tenureStatus = getPersonTenureStatus(person.id, track)
                  if (tenureStatus && tenureStatus.status !== 'ok') {
                    const indicator = document.createElement('button')
                    indicator.type = 'button'
                    indicator.className = 'person-tenure-indicator'
                    indicator.dataset.status = tenureStatus.status
                    if (tenureStatus.status === 'soft') {
                      indicator.classList.add('person-tenure-indicator-soft')
                      personEl.classList.add('person-tenure-soft')
                    } else if (tenureStatus.status === 'hard') {
                      indicator.classList.add('person-tenure-indicator-hard')
                      personEl.classList.add('person-tenure-hard')
                    }
                    const tenureLabel = formatTenureDuration(tenureStatus.days)
                    const softLabel = formatTenureThresholdValue(tenureStatus.thresholds.softDays)
                    const hardLabel = formatTenureThresholdValue(tenureStatus.thresholds.hardDays)
                    indicator.textContent = tenureLabel
                    indicator.title = `${person.name} has been in ${track.name} for ${tenureLabel}. Soft warning ${softLabel}d, strong ${hardLabel}d. Click to sweep to On Deck.`
                    indicator.draggable = false
                    indicator.addEventListener('click', (ev) => {

                      if (Date.now() < suppressTenureIndicatorClickUntil) {
                        return
                      }
                      ev.preventDefault()
                      sweepPerson(person.id)
                    })
                    personEl.dataset.tenureStatus = tenureStatus.status
                    tenureIndicatorButton = indicator
                  }
                }

                if (tenureIndicatorButton) {
                  nameContainer.appendChild(tenureIndicatorButton)
                }

                personEl.appendChild(nameContainer)

                const actions = document.createElement('div')
                actions.className = 'person-actions'

                const actionsLeft = document.createElement('div')
                actionsLeft.className = 'actions-left'

                const actionsRight = document.createElement('div')
                actionsRight.className = 'actions-right'

                const isPendingRetire = pendingRetirePersonId === person.id


                if (isPendingRetire) {
                  personEl.classList.add('person-pending-retire')
                }

                if (!isPendingRetire) {
                  const shuffleBtn = document.createElement('button')
                  shuffleBtn.textContent = '🔀'
                  shuffleBtn.title = 'Shuffle to another track'
                  shuffleBtn.className = 'primary'
                  shuffleBtn.dataset.label = 'Shuffle'
                  shuffleBtn.draggable = false
                  shuffleBtn.addEventListener('click', () => {
                    shufflePerson(person.id)
                  })
                  actionsLeft.appendChild(shuffleBtn)

                  if (track.type !== 'on_deck') {
                    const sweepBtn = document.createElement('button')
                    sweepBtn.textContent = '⬅️'
                    sweepBtn.title = 'Sweep to On Deck'
                    sweepBtn.draggable = false
                    sweepBtn.addEventListener('click', () => {
                      sweepPerson(person.id)
                    })
                    actionsLeft.appendChild(sweepBtn)
                  }

                  const moveCandidates = state.tracks.filter((t) => {
                    if (t.id === track.id) return false
                    if (t.type === 'out_of_office') return false
                    return trackHasCapacity(t)
                  })

                  const moveSelect = document.createElement('select')
                  moveSelect.setAttribute('aria-label', 'Move to track')

                  const placeholderOption = document.createElement('option')
                  placeholderOption.value = ''
                  placeholderOption.textContent = 'Move…'
                  placeholderOption.disabled = true
                  placeholderOption.selected = true
                  moveSelect.appendChild(placeholderOption)

                  for (const t of moveCandidates) {
                    const opt = document.createElement('option')
                    opt.value = t.id
                    opt.textContent = t.name
                    moveSelect.appendChild(opt)
                  }

                  const newTrackOption = document.createElement('option')
                  newTrackOption.value = NEW_TRACK_OPTION_VALUE
                  newTrackOption.textContent = '➕ New track…'
                  moveSelect.appendChild(newTrackOption)

                  moveSelect.addEventListener('change', (ev) => {
                    const targetId = ev.target.value
                    if (!targetId) return
                    if (targetId === NEW_TRACK_OPTION_VALUE) {
                      createTrackFromPersonDrop(person.id)
                      return
                    }
                    movePersonToTrack(person.id, targetId)
                  })

                  actionsLeft.appendChild(moveSelect)
                }

                const retireBtn = document.createElement('button')
                if (isPendingRetire) {
                  retireBtn.textContent = '✅'
                  retireBtn.className = 'retire-button'
                  retireBtn.dataset.state = 'confirm'
                  retireBtn.title = `Confirm retire ${person.name}`
                } else {
                  retireBtn.textContent = '👋'
                  retireBtn.className = 'retire-button'
                  retireBtn.title = 'Retire from planner'
                }
                attachDragEvents(retireBtn, person.id)
                retireBtn.addEventListener('click', () => {
                  if (pendingRetirePersonId === person.id) {
                    retirePerson(person.id)
                  } else {
                    pendingRetirePersonId = person.id
                    render()
                  }
                })
                actionsRight.appendChild(retireBtn)

                if (isPendingRetire) {
                  const cancelRetireBtn = document.createElement('button')
                  cancelRetireBtn.textContent = '✖️'
                  cancelRetireBtn.title = 'Cancel'
                  attachDragEvents(cancelRetireBtn, person.id)
                  cancelRetireBtn.addEventListener('click', () => {
                    pendingRetirePersonId = null
                    render()
                  })
                  actionsRight.appendChild(cancelRetireBtn)
                }

                actions.appendChild(actionsLeft)
                actions.appendChild(actionsRight)

                personEl.appendChild(actions)
                peopleList.appendChild(personEl)
              }
            }

            trackEl.appendChild(peopleList)

            const rolesList = document.createElement('div')
            rolesList.className = 'roles-list'
            rolesList.dataset.trackId = track.id
            if (track.type === 'normal') {
              rolesList.addEventListener('dragenter', (ev) =>
                onDragEnterRolesList(ev, track.id),
              )
              rolesList.addEventListener('dragover', (ev) =>
                onDragOverRolesList(ev, track.id),
              )
              rolesList.addEventListener('dragleave', onDragLeaveRolesList)
              rolesList.addEventListener('drop', (ev) =>
                onDropOnRolesList(ev, track.id),
              )
              if (!track.roleIds.length) {
                rolesList.classList.add('empty')
                const emptyRole = document.createElement('span')
                emptyRole.className = 'muted'
                emptyRole.textContent = 'No roles'
                rolesList.appendChild(emptyRole)
              } else {
                for (const roleId of track.roleIds) {
                  const role = getRoleById(roleId)
                  if (!role) continue
                  const roleEl = document.createElement('div')
                  roleEl.className = 'role-pill'
                  roleEl.dataset.roleId = role.id
                  roleEl.draggable = true
                  roleEl.addEventListener('dragstart', (ev) =>
                    onDragStartRole(ev, role.id),
                  )
                  roleEl.addEventListener('dragend', onDragEndRole)

                  const roleInfo = document.createElement('div')
                  roleInfo.className = 'role-info'
                  const colorDot = document.createElement('span')
                  colorDot.className = 'role-color-dot'
                  colorDot.style.background = role.color || 'var(--accent)'
                  roleInfo.appendChild(colorDot)

                  const roleName = document.createElement('span')
                  roleName.className = 'role-name'
                  roleName.textContent = role.name
                  roleName.title = 'Click to rename role'
                  roleName.style.cursor = 'pointer'
                  roleName.addEventListener('click', () => {
                    const newName = prompt('New role name?', role.name)
                    if (!newName) return
                    updateRoleName(role.id, newName)
                  })
                  roleInfo.appendChild(roleName)

                  const roleActions = document.createElement('div')
                  roleActions.className = 'role-actions'

                  const roleActionsLeft = document.createElement('div')
                  roleActionsLeft.className = 'actions-left'

                  const roleActionsRight = document.createElement('div')
                  roleActionsRight.className = 'actions-right'

                  const shuffleBtn = document.createElement('button')
                  shuffleBtn.textContent = '🔀'
                  shuffleBtn.title = 'Shuffle role to another track'
                  shuffleBtn.className = 'primary'
                  shuffleBtn.dataset.label = 'Shuffle'
                  shuffleBtn.addEventListener('click', () => {
                    shuffleRole(role.id)
                  })
                  roleActionsLeft.appendChild(shuffleBtn)


                  const moveSelect = document.createElement('select')

                  moveSelect.setAttribute('aria-label', 'Move role to track')

                  const movePlaceholder = document.createElement('option')
                  movePlaceholder.value = ''
                  movePlaceholder.textContent = 'Move…'
                  movePlaceholder.disabled = true
                  movePlaceholder.selected = true
                  moveSelect.appendChild(movePlaceholder)

                  const roleMoveCandidates = state.tracks.filter(
                    (t) => t.type === 'normal' && t.id !== track.id,
                  )
                  for (const candidate of roleMoveCandidates) {
                    const opt = document.createElement('option')
                    opt.value = candidate.id
                    opt.textContent = candidate.name
                    moveSelect.appendChild(opt)
                  }

                  const newRoleTrackOption = document.createElement('option')
                  newRoleTrackOption.value = NEW_TRACK_OPTION_VALUE
                  newRoleTrackOption.textContent = '➕ New track…'
                  moveSelect.appendChild(newRoleTrackOption)

                  moveSelect.addEventListener('change', (ev) => {
                    const targetId = ev.target.value
                    if (!targetId) return
                    if (targetId === NEW_TRACK_OPTION_VALUE) {
                      mutateState(`Create track for role ${role.name}`, () => {
                        const newTrack = createNormalTrack()
                        if (!newTrack) return false
                        return moveRoleToTrackInternal(role.id, newTrack.id)
                      })
                    } else {
                      moveRoleToTrack(role.id, targetId)
                    }
                    ev.target.value = ''
                  })
                  roleActionsLeft.appendChild(moveSelect)

                  const deleteBtn = document.createElement('button')
                  deleteBtn.textContent = '🗑️'
                  deleteBtn.className = 'role-delete'
                  deleteBtn.title = `Delete role ${role.name}`
                  deleteBtn.addEventListener('click', () => {
                    deleteRole(role.id)
                  })
                  roleActionsRight.appendChild(deleteBtn)

                  roleActions.appendChild(roleActionsLeft)
                  roleActions.appendChild(roleActionsRight)

                  roleEl.appendChild(roleInfo)
                  roleEl.appendChild(roleActions)
                  rolesList.appendChild(roleEl)
                }
              }
            } else {
              rolesList.classList.add('empty')
              const unavailable = document.createElement('span')
              unavailable.className = 'muted'
              unavailable.textContent = 'Roles unavailable'
              rolesList.appendChild(unavailable)
            }

            trackEl.appendChild(rolesList)
            container.appendChild(trackEl)
          }

          const dropZone = document.createElement('div')
          dropZone.id = 'createTrackDropZone'
          dropZone.className = 'create-track-drop-zone'
          dropZone.textContent = 'Drop to create a new track'
          dropZone.setAttribute('role', 'button')
          dropZone.setAttribute('aria-hidden', currentDragPersonId ? 'false' : 'true')
          dropZone.setAttribute('aria-label', 'Drop to create a new track')
          dropZone.addEventListener('dragenter', onDragEnterDropZone)
          dropZone.addEventListener('dragover', onDragOverDropZone)
          dropZone.addEventListener('dragleave', onDragLeaveDropZone)
          dropZone.addEventListener('drop', onDropOnDropZone)
          if (currentDragPersonId) {
            dropZone.classList.add('visible')
          }

          container.appendChild(dropZone)
          updateHistoryControls()
          playPendingAnimation()
          flushHistoryAnnouncement()
        }

        if (typeof window !== 'undefined') {
          window.__mobbistTestHooks = {
            checkBackendReachability,
            updateBackendStatusBadge,
            backendConfig,
            normalizeBackendUrl,
            loadBackendConfig,
            saveBackendConfig,
            loadFromBackend,
            saveToBackend,
            revertToLocal,
            workspaceMeta,
            getState: () => state,
            setState: (next, markDirty = true) => {
              state = next
              if (markDirty) dirtySinceServerLoad = true
              render()
            },
            setDirtySinceServerLoad: (value) => {
              dirtySinceServerLoad = Boolean(value)
            },
          }
        }

        function init() {
          state = loadState()
          updateBackendStatusBadge(backendConfig.reachability)

          historyAnnouncerEl = document.getElementById('historyAnnouncer')

          const backendUrlInput = document.getElementById('backendUrlInput')
          const checkBackendButton = document.getElementById('checkBackendButton')
          const loadBackendButton = document.getElementById('loadBackendButton')
          const saveBackendButton = document.getElementById('saveBackendButton')
          const revertToLocalButton = document.getElementById('revertToLocalButton')

          if (backendUrlInput) {
            backendUrlInput.value = backendConfig.backendUrl || ''
            backendUrlInput.addEventListener('blur', () => {
              backendUrlInput.value = normalizeBackendUrl(backendUrlInput.value)
            })
          }

          if (checkBackendButton) {
            checkBackendButton.addEventListener('click', async (ev) => {
              ev.preventDefault()
              const nextUrl = backendUrlInput ? backendUrlInput.value : ''
              backendConfig.backendUrl = normalizeBackendUrl(nextUrl)
              saveBackendConfig(backendConfig)
              await checkBackendReachability()
            })
          }

          if (revertToLocalButton) {
            revertToLocalButton.addEventListener('click', (ev) => {
              ev.preventDefault()
              const confirmReset = window.confirm(
                'Revert to local will disable backend usage and keep your current local state. Continue?',
              )
              if (!confirmReset) return
              revertToLocal()
              workspaceMeta = createDefaultWorkspaceMeta()
              saveWorkspaceMeta(workspaceMeta)
              if (backendUrlInput) backendUrlInput.value = ''
              alert('Backend disabled. Running in local-only mode.')
            })
          }

          if (loadBackendButton) {
            loadBackendButton.addEventListener('click', async (ev) => {
              ev.preventDefault()
              const ok = await loadFromBackend()
              if (!ok) alert('Failed to load from backend. Staying on local data.')
            })
          }

          if (saveBackendButton) {
            saveBackendButton.addEventListener('click', async (ev) => {
              ev.preventDefault()
              const ok = await saveToBackend()
              if (!ok) alert('Failed to save to backend. Local data is still intact.')
            })
          }

          if (backendConfig.backendUrl) {
            checkBackendReachability().catch((err) => {
              console.warn('Backend check failed; staying in local mode.', err)
            })
          }

          undoButtonEl = document.getElementById('undoButton')
          if (undoButtonEl) {
            undoButtonEl.addEventListener('click', (ev) => {
              ev.preventDefault()
              undoLastAction()
            })
          }

          redoButtonEl = document.getElementById('redoButton')
          if (redoButtonEl) {
            redoButtonEl.addEventListener('click', (ev) => {
              ev.preventDefault()
              redoLastAction()
            })
          }

          if (!historyShortcutBound) {
            document.addEventListener('keydown', handleHistoryShortcut)
            document.addEventListener('dragover', onGlobalDragOver, true)
            document.addEventListener('drop', onGlobalDrop, true)
            document.addEventListener('paste', handlePlannerPaste)
            historyShortcutBound = true
          }

          const addPeopleButton = document.getElementById('addPeopleButton')
          if (addPeopleButton) {
            addPeopleButton.addEventListener('click', addPeopleFromTextarea)
          }

          const resetPlanButton = document.getElementById('resetPlanButton')
          if (resetPlanButton) {
            resetPlanButton.addEventListener('click', resetPlan)
          }

          const exportClipboardButton = document.getElementById('exportClipboardButton')
          if (exportClipboardButton) {
            exportClipboardButton.addEventListener('click', () => {
              exportBoardToClipboard()
            })
          }

          const importClipboardButton = document.getElementById('importClipboardButton')
          if (importClipboardButton) {
            importClipboardButton.addEventListener('click', () => {
              importBoardFromClipboard()
            })
          }

          const addRoleButton = document.getElementById('addRoleButton')
          if (addRoleButton) {
            addRoleButton.addEventListener('click', () => {
              const roleName = prompt('Role name?')
              if (!roleName || !roleName.trim()) return
              const colorInput = prompt(
                'Role accent color (optional, leave blank for default):',
                '',
              )
              const color = colorInput && colorInput.trim() ? colorInput.trim() : null
              createRole({ name: roleName, color })
            })
          }

          const shuffleRolesButtonEl = document.getElementById('shuffleRolesButton')
          if (shuffleRolesButtonEl) {
            shuffleRolesButtonEl.addEventListener('click', () => {
              shuffleAllRoles()
            })
          }

          const deleteSelectedTracksButton = document.getElementById('deleteSelectedTracksButton')
          if (deleteSelectedTracksButton) {
            deleteSelectedTracksButton.addEventListener('click', () => {
              deleteSelectedTracks()
            })
          }

          const sweepAllTracksButton = document.getElementById('sweepAllTracksButton')
          if (sweepAllTracksButton) {
            sweepAllTracksButton.addEventListener('click', () => {
              sweepAllTracksKeepOne()
            })
          }

          const deleteAllTracksButton = document.getElementById('deleteAllTracksButton')
          if (deleteAllTracksButton) {
            deleteAllTracksButton.addEventListener('click', () => {
              deleteAllTracks()
            })
          }

          const defaultCapacityInput = document.getElementById('defaultCapacityInput')
          if (defaultCapacityInput) {
            defaultCapacityInput.addEventListener('change', (ev) => {
              const raw = ev.target.value.trim()
              let value = Number(raw)
              if (!raw || Number.isNaN(value) || value < 1) {
                value = 2
              }
              if (state.defaultTrackCapacity === value) {
                defaultCapacityInput.value = String(value)
                return
              }
              mutateState(`Set default track capacity to ${value}`, () => {
                state.defaultTrackCapacity = value
                return true
              })
            })
          }

          const tenureSoftInput = document.getElementById('tenureSoftInput')
          const tenureHardInput = document.getElementById('tenureHardInput')
          const handleTenureInputChange = () => {
            ensureTenureContainer()
            const softRaw = tenureSoftInput ? tenureSoftInput.value.trim() : ''
            const hardRaw = tenureHardInput ? tenureHardInput.value.trim() : ''
            const softValue = softRaw ? Number(softRaw) : state.tenure.config.softDays
            const hardValue = hardRaw ? Number(hardRaw) : state.tenure.config.hardDays
            if (!Number.isFinite(softValue) || softValue <= 0) {
              if (tenureSoftInput) {
                tenureSoftInput.value = formatTenureThresholdValue(state.tenure.config.softDays)
              }
              alert('Soft warning threshold must be a positive number.')
              return
            }
            if (!Number.isFinite(hardValue) || hardValue <= 0) {
              if (tenureHardInput) {
                tenureHardInput.value = formatTenureThresholdValue(state.tenure.config.hardDays)
              }
              alert('Strong warning threshold must be a positive number.')
              return
            }
            setGlobalTenureConfig(softValue, hardValue)
          }

          if (tenureSoftInput) {
            tenureSoftInput.addEventListener('change', handleTenureInputChange)
          }
          if (tenureHardInput) {
            tenureHardInput.addEventListener('change', handleTenureInputChange)
          }

          const sortTenureButtonEl = document.getElementById('sortTenureButton')
          if (sortTenureButtonEl) {
            sortTenureButtonEl.addEventListener('click', () => {
              sortTracksByTenure()
            })
          }

          const listStrongTenureButtonEl = document.getElementById('listStrongTenureButton')
          if (listStrongTenureButtonEl) {
            listStrongTenureButtonEl.addEventListener('click', () => {
              announceStrongTenureBreaches()
            })
          }

          render()
          maybeAutoLoadClipboardFromQuery().catch((error) => {
            console.error('Failed to auto-import board from clipboard.', error)
          })
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init)
        } else {
          init()
        }
      })()
    </script>
  </body>
</html>
