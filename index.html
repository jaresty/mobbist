<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mobbist</title>
      <style>
      :root {
        --bg: #f4f4f4;
        --card-bg: #ffffff;
        --border: #dddddd;
        --accent: #0070f3;
        --accent-soft: #e3f1ff;
        --danger: #b3261e;
        --muted: #666666;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        margin: 24px;
        background: var(--bg);
        color: #111827;
      }

      h1 {
        margin: 0 0 4px;
        font-size: 1.6rem;
      }

      p {
        margin: 0 0 12px;
        color: var(--muted);
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
      }

      .layout-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 16px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      .controls .history-btn {
        min-width: 160px;
        text-align: left;
      }

      textarea {
        width: 100%;
        min-height: 80px;
        padding: 8px;
        font-size: 14px;
        resize: vertical;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
      }

      button {
        padding: 6px 12px;
        cursor: pointer;
        font-size: 13px;
        border-radius: 4px;
        border: 1px solid var(--border);
        background: #ffffff;
        color: #111827;
      }

      button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #ffffff;
      }

      button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: #ffffff;
      }

      button.ghost {
        background: transparent;
      }

      button:disabled {
        opacity: 0.5;
        cursor: default;
      }

      .tracks-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 8px 0 12px;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tracks-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 12px;
        align-items: flex-start;
      }

      .create-track-drop-zone {
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        border: 2px dashed var(--accent);
        border-radius: 6px;
        background: var(--accent-soft);
        color: var(--accent);
        font-weight: 600;
        min-height: 96px;
        transition: background 120ms ease, color 120ms ease, border-color 120ms ease;
      }

      .create-track-drop-zone.visible {
        display: flex;
      }

      .create-track-drop-zone.hover {
        background: var(--accent);
        color: #ffffff;
        border-color: var(--accent);
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .history-animation-layer {
        position: fixed;
        inset: 0;
        pointer-events: none;
        overflow: visible;
        z-index: 999;
      }

      .history-ghost {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 8px;
        border-radius: 6px;
        background: #ffffff;
        box-shadow: 0 0 0 2px var(--accent);
        font-size: 0.85rem;
        color: #111827;
        pointer-events: none;
        transform: translate(0, 0);
        opacity: 1;
        transform-origin: top left;
        white-space: nowrap;
        will-change: transform, opacity;
      }

      .person.history-flash {
        animation: historyFlash 600ms ease;
      }

      @keyframes historyFlash {
        from {
          background: var(--accent-soft);
        }
        to {
          background: #ffffff;
        }
      }

      .track {
        background: var(--card-bg);
        border-radius: 6px;
        border: 1px solid var(--border);
        padding: 8px;
        display: flex;
        flex-direction: column;
        min-height: 120px;
      }

      .track-header {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 6px;
      }

      .track-header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        min-width: 0;
      }

      .track-title {
        font-weight: 600;
        font-size: 0.95rem;
        word-break: break-word;
        overflow-wrap: anywhere;
        min-width: 0;
      }

      .track-type {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }

      .track-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        font-size: 0.75rem;
      }

      .capacity-input {
        width: 60px;
        padding: 3px 4px;
        font-size: 0.75rem;
      }

      .track-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }

      .people-list {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 4px;
        border-radius: 4px;
        background: #f9fafb;
        min-height: 60px;
        max-height: 260px;
        overflow-y: auto;
      }

      .people-list.empty {
        font-size: 0.8rem;
        color: var(--muted);
        align-items: center;
        justify-content: center;
        display: flex;
      }

      .people-list.drop-target {
        outline: 2px dashed var(--accent);
        background: var(--accent-soft);
      }

      .person {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 6px;
        flex-wrap: wrap;
        padding: 4px 6px;
        border-radius: 4px;
        background: #ffffff;
        border: 1px solid var(--border);
        font-size: 0.85rem;
      }

      .person-name {
        flex: 1 1 auto;
        word-break: break-word;
        overflow-wrap: anywhere;
        min-width: 0;
      }

      .person-actions {
        display: flex;
        gap: 2px;
        flex-wrap: wrap;
        justify-content: flex-start;
        flex: 0 0 auto;
      }

      .person-actions button {
        padding: 2px 6px;
        font-size: 0.7rem;
      }

      .person-actions .retire-button {
        border-color: var(--danger);
        color: var(--danger);
        background: #fef2f2;
        margin-left: 8px;
      }

      .person-actions .danger {
        margin-left: 8px;
      }

      .person-pending-retire {
        background: #fef2f2;
      }

      .person-pending-retire .person-name::after {
        content: ' (retiring…)';
        font-size: 0.75rem;
        color: var(--danger);
      }

      .person-actions select {
        padding: 2px 4px;
        font-size: 0.7rem;
        max-width: 80px;
      }

      @media (min-width: 768px) {
        .person-actions button[data-label]::after {
          content: ' ' attr(data-label);
        }
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e5e7eb;
        font-size: 0.7rem;
      }

      .badge-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--accent);
        margin-right: 4px;
      }

      .muted {
        color: var(--muted);
      }

      .track-full {
        border-color: #f97316;
      }

      @media (max-width: 600px) {
        body {
          margin: 12px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="layout-header">
        <div>
          <h1>Mobbist</h1>
          <p>Plan pairs and mobs and reshuffle people quickly in your browser.</p>
        </div>
        <div class="controls">
          <button id="undoButton" class="ghost history-btn" disabled>Undo</button>
          <button id="redoButton" class="ghost history-btn" disabled>Redo</button>
          <button id="resetPlanButton" class="ghost">Reset plan</button>
        </div>
      </div>

      <section class="stack">
        <label for="bulkNamesInput" style="font-size:0.85rem;">Add people (one name per line):</label>
        <textarea
          id="bulkNamesInput"
          placeholder="Alice&#10;Bob&#10;Charlie&#10;Dana"
        ></textarea>
        <div>
          <button id="addPeopleButton" class="primary">Add people to On Deck</button>
        </div>
      </section>

      <section class="tracks-toolbar">
        <div class="muted" style="font-size:0.8rem;">
          Tracks: On Deck distributes into all normal tracks. Out of Office is excluded from random allocation.
        </div>
        <div class="muted" style="font-size:0.75rem; display:flex; align-items:center; gap:4px; flex-wrap:wrap;">
           <label for="defaultCapacityInput">Default capacity:</label>
            <input id="defaultCapacityInput" type="number" min="1" value="2" style="width:3rem; padding:2px 4px; font-size:0.75rem;" />
            <button id="sweepAllTracksButton" disabled>Sweep all tracks</button>
            <button id="deleteSelectedTracksButton" class="danger" disabled>Delete selected tracks</button>
            <button id="deleteAllTracksButton" class="danger" disabled>Delete all tracks</button>
         </div>
         <div id="capacityNotice" class="muted" style="font-size:0.75rem;"></div>


      </section>

      <section id="tracksContainer" class="tracks-grid" aria-label="Tracks"></section>
      <div id="historyAnnouncer" class="visually-hidden" aria-live="polite" aria-atomic="true"></div>
      <div id="historyOverlay" class="history-animation-layer"></div>
    </main>

    <script>
      ;(function () {
        const STORAGE_KEY = 'mobbist:v1'
        const LEGACY_STORAGE_KEYS = ['pairPlanner:v1']
        const NEW_TRACK_OPTION_VALUE = '__create_new_track__'
        const HISTORY_LIMIT = 30

        /**
         * @typedef {{ id: string, name: string }} Person
         * @typedef {{ id: string, name: string, type: 'normal' | 'on_deck' | 'out_of_office', capacity: number | null, personIds: string[] }} Track
         * @typedef {{ people: Person[], tracks: Track[], nextPersonId: number, nextTrackId: number, defaultTrackCapacity: number }} PlannerState
         */

        /** @type {PlannerState} */
        let state
        let currentDragPersonId = null
        let pendingRetirePersonId = null
        /** @type {Set<string>} */
        let selectedTrackIds = new Set()
        /** @type {{ description: string, state: PlannerState }[]} */
        let undoStack = []
        /** @type {{ description: string, state: PlannerState }[]} */
        let redoStack = []
        let pendingHistoryAnnouncement = ''
        let pendingAnimationPositions = null
        let pendingAnimatedPersonIds = null
        let historyAnnouncerEl = null
        let undoButtonEl = null
        let redoButtonEl = null
        let historyShortcutBound = false
        let historyOverlayEl = null

        function createInitialState() {

          return {
            people: [],
            tracks: [
              {
                id: 'on_deck',
                name: 'On Deck',
                type: 'on_deck',
                capacity: null,
                personIds: [],
              },
              {
                id: 'out_of_office',
                name: 'Out of Office',
                type: 'out_of_office',
                capacity: null,
                personIds: [],
              },
              {
                id: 'track-1',
                name: 'Track A',
                type: 'normal',
                capacity: 2,
                personIds: [],
              },
            ],
            nextPersonId: 1,
            nextTrackId: 2,
            defaultTrackCapacity: 2,
          }
        }

        function ensureHistoryOverlay() {
          if (historyOverlayEl && document.body.contains(historyOverlayEl)) {
            return historyOverlayEl
          }
          historyOverlayEl = document.getElementById('historyOverlay')
          if (!historyOverlayEl) {
            historyOverlayEl = document.createElement('div')
            historyOverlayEl.id = 'historyOverlay'
            historyOverlayEl.className = 'history-animation-layer'
            document.body.appendChild(historyOverlayEl)
          }
          return historyOverlayEl
        }

        function loadState() {
          try {
            let raw = window.localStorage.getItem(STORAGE_KEY)
            if (!raw) {
              for (const legacyKey of LEGACY_STORAGE_KEYS) {
                raw = window.localStorage.getItem(legacyKey)
                if (raw) break
              }
            }
            if (!raw) return createInitialState()
            const parsed = JSON.parse(raw)
            if (!parsed || !Array.isArray(parsed.people) || !Array.isArray(parsed.tracks)) {
              return createInitialState()
            }
            if (typeof parsed.nextPersonId !== 'number') parsed.nextPersonId = 1
            if (typeof parsed.nextTrackId !== 'number') parsed.nextTrackId = 1
            if (typeof parsed.defaultTrackCapacity !== 'number' || parsed.defaultTrackCapacity < 1) {
              parsed.defaultTrackCapacity = 2
            }
            return parsed
          } catch (e) {
            console.warn('Failed to load planner state, resetting.', e)
            return createInitialState()
          }
        }

        function saveState() {
          try {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
          } catch (e) {
            console.warn('Failed to save planner state.', e)
          }
        }

        function getTrackByType(type) {
          return state.tracks.find((t) => t.type === type) || null
        }

        function getTrackById(id) {
          return state.tracks.find((t) => t.id === id) || null
        }

        function getPersonById(id) {
          return state.people.find((p) => p.id === id) || null
        }

        function updatePersonName(personId, newName) {
          const person = getPersonById(personId)
          if (!person) return false
          const trimmed = newName.trim()
          if (!trimmed) return false
          const previousName = person.name
          if (trimmed === previousName) return false
          return mutateState(`Rename ${previousName} to ${trimmed}`, () => {
            person.name = trimmed
            return true
          })
        }

        function trackHasCapacity(track) {
          if (track.capacity == null) return true
          return track.personIds.length < track.capacity
        }

        function generateAutomaticTrackName(counter = state.nextTrackId) {
          const letterIndex = counter
          if (letterIndex >= 1 && letterIndex <= 26) {
            return `Track ${String.fromCharCode(64 + letterIndex)}`
          }
          return `Track ${letterIndex}`
        }

        function setDropZoneActive(active) {
          const dropZone = document.getElementById('createTrackDropZone')
          if (!dropZone) return
          if (active) {
            dropZone.classList.add('visible')
            dropZone.setAttribute('aria-hidden', 'false')
          } else {
            dropZone.classList.remove('visible')
            dropZone.classList.remove('hover')
            dropZone.setAttribute('aria-hidden', 'true')
          }
        }

        function createTrackFromPersonDrop(personId) {
          const person = getPersonById(personId)
          if (!person) return false
          const description = `Create track for ${person.name}`
          return mutateState(description, () => {
            const sourceTrack = state.tracks.find((t) => t.personIds.includes(personId))
            if (sourceTrack) {
              sourceTrack.personIds = sourceTrack.personIds.filter((id) => id !== personId)
            }

            const trackCounter = state.nextTrackId++
            const newTrackId = 'track-' + trackCounter
            const trackName = generateAutomaticTrackName(trackCounter)
            const newTrack = {
              id: newTrackId,
              name: trackName,
              type: 'normal',
              capacity: null,
              personIds: [personId],
            }

            state.tracks.push(newTrack)
            return true
          })
        }

        function snapshotPlannerState(source = state) {
          return JSON.parse(JSON.stringify(source))
        }

        function buildTrackAssignments(snapshot) {
          const assignments = new Map()
          snapshot.tracks.forEach((track) => {
            track.personIds.forEach((personId, index) => {
              assignments.set(personId, { trackId: track.id, index })
            })
          })
          return assignments
        }

        function shouldAnimatePerson(personId) {
          if (!pendingAnimatedPersonIds) return true
          return pendingAnimatedPersonIds.has(personId)
        }

        function announceHistory(message) {
          if (!message) return
          pendingHistoryAnnouncement = message
        }

        function mutateState(description, mutator) {
          pendingAnimatedPersonIds = null
          const previousPositions = capturePersonPositions()
          const previousState = snapshotPlannerState()
          const previousSerialized = JSON.stringify(previousState)
          const result = mutator()
          if (result === false) return false
          const nextSerialized = JSON.stringify(state)
          if (previousSerialized === nextSerialized) {
            return result
          }
          const prevAssignments = buildTrackAssignments(previousState)
          const nextAssignments = buildTrackAssignments(state)
          const animatedIds = new Set()
          prevAssignments.forEach((info, personId) => {
            const nextInfo = nextAssignments.get(personId)
            if (!nextInfo || nextInfo.trackId !== info.trackId) {
              animatedIds.add(personId)
            }
          })
          nextAssignments.forEach((info, personId) => {
            if (!prevAssignments.has(personId)) {
              animatedIds.add(personId)
            }
          })
          pendingAnimatedPersonIds = animatedIds.size ? animatedIds : null
          pendingAnimationPositions = previousPositions
          undoStack.push({ description, state: previousState })
          if (undoStack.length > HISTORY_LIMIT) {
            undoStack.shift()
          }
          redoStack = []
          announceHistory(`${description}. Undo available.`)
          saveState()
          render()
          return result
        }

        function updateHistoryControls() {
          if (!undoButtonEl || !redoButtonEl) return
          const undoEntry = undoStack[undoStack.length - 1] || null
          const redoEntry = redoStack[redoStack.length - 1] || null
          undoButtonEl.disabled = !undoEntry
          redoButtonEl.disabled = !redoEntry
          undoButtonEl.textContent = undoEntry ? `Undo ${undoEntry.description}` : 'Undo'
          redoButtonEl.textContent = redoEntry ? `Redo ${redoEntry.description}` : 'Redo'
          undoButtonEl.setAttribute('aria-disabled', undoButtonEl.disabled ? 'true' : 'false')
          redoButtonEl.setAttribute('aria-disabled', redoButtonEl.disabled ? 'true' : 'false')

        }

        function capturePersonPositions() {
          const positions = {}
          const peopleEls = document.querySelectorAll('.person')
          peopleEls.forEach((el) => {
            const personId = el.dataset.personId
            if (!personId) return
            const rect = el.getBoundingClientRect()
            const nameEl = el.querySelector('.person-name')
            const label = nameEl ? nameEl.textContent?.trim() || '' : el.textContent?.trim() || ''
            const listEl = el.closest('.people-list')
            const trackId = listEl ? listEl.dataset.trackId || null : null
            const peers = listEl ? Array.from(listEl.querySelectorAll('.person')) : []
            const index = peers.indexOf(el)
            positions[personId] = {
              left: rect.left,
              top: rect.top,
              width: rect.width,
              height: rect.height,
              label,
              trackId,
              index,
            }
          })
          return positions
        }

        function spawnHistoryGhost(prev, options = {}) {
          const overlay = ensureHistoryOverlay()
          if (!overlay) return
          const {
            deltaX = 0,
            deltaY = 0,
            finalOpacity = 0,
            label = prev.label || '',
            duration = 600,
          } = options
          const ghost = document.createElement('div')
          ghost.className = 'history-ghost'
          ghost.textContent = label
          ghost.style.position = 'absolute'
          ghost.style.left = `${prev.left}px`
          ghost.style.top = `${prev.top}px`
          ghost.style.width = `${prev.width}px`
          ghost.style.height = `${prev.height}px`
          ghost.style.transform = 'translate(0, 0)'
          ghost.style.opacity = '1'
          overlay.appendChild(ghost)
          requestAnimationFrame(() => {
            ghost.style.transition = `transform ${duration}ms ease, opacity ${duration}ms ease`
            ghost.style.transform = `translate(${deltaX}px, ${deltaY}px)`
            ghost.style.opacity = `${finalOpacity}`
          })
          ghost.addEventListener(
            'transitionend',
            () => {
              ghost.remove()
            },
            { once: true },
          )
          window.setTimeout(() => {
            if (ghost.isConnected) {
              ghost.remove()
            }
          }, duration + 120)
        }

        function highlightPersonArrival(el) {
          el.classList.add('history-flash')
          el.addEventListener(
            'animationend',
            () => {
              el.classList.remove('history-flash')
            },
            { once: true },
          )
        }

        function playPendingAnimation() {
          if (!pendingAnimationPositions) {
            pendingAnimatedPersonIds = null
            return
          }
          const previous = pendingAnimationPositions
          pendingAnimationPositions = null
          const reduceMotion =
            window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches
          if (reduceMotion) {
            pendingAnimatedPersonIds = null
            return
          }

          const overlay = ensureHistoryOverlay()
          if (overlay) {
            overlay.innerHTML = ''
          }

          const handled = new Set()
          const peopleEls = document.querySelectorAll('.person')
          peopleEls.forEach((el) => {
            const personId = el.dataset.personId
            if (!personId) return
            const rect = el.getBoundingClientRect()
            const prev = previous[personId]
            if (!prev) {
              if (shouldAnimatePerson(personId)) {
                highlightPersonArrival(el)
              }
              return
            }
            handled.add(personId)
            const listEl = el.closest('.people-list')
            const currentTrackId = listEl ? listEl.dataset.trackId || null : null
            const peers = listEl ? Array.from(listEl.querySelectorAll('.person')) : []
            const currentIndex = peers.indexOf(el)
            const prevTrackId = Object.prototype.hasOwnProperty.call(prev, 'trackId') ? prev.trackId : null
            const prevIndex = typeof prev.index === 'number' ? prev.index : -1
            const trackChanged = prevTrackId !== currentTrackId
            const indexChanged = prevIndex !== currentIndex
            if (trackChanged || indexChanged) {
              if (!shouldAnimatePerson(personId)) {
                return
              }
              const deltaX = rect.left - prev.left
              const deltaY = rect.top - prev.top
              spawnHistoryGhost(prev, {
                deltaX,
                deltaY,
                label: prev.label,
              })
              highlightPersonArrival(el)
            }
          })

          Object.keys(previous).forEach((personId) => {
            if (handled.has(personId)) return
            const prev = previous[personId]
            if (!prev) return
            if (!shouldAnimatePerson(personId)) return
            spawnHistoryGhost(prev, {
              deltaX: 0,
              deltaY: -24,
              label: prev.label,
            })
          })
          pendingAnimatedPersonIds = null
        }

        function flushHistoryAnnouncement() {
          if (!historyAnnouncerEl || !pendingHistoryAnnouncement) return
          historyAnnouncerEl.textContent = pendingHistoryAnnouncement
          pendingHistoryAnnouncement = ''
        }

        function applyStateSnapshot(snapshot) {
          state = snapshotPlannerState(snapshot)
          selectedTrackIds = new Set()
          pendingRetirePersonId = null
        }


        function clearObsoleteTrackSelections() {
          const existingIds = new Set(
            state.tracks.filter((t) => t.type === 'normal').map((t) => t.id),
          )
          selectedTrackIds = new Set(
            [...selectedTrackIds].filter((id) => existingIds.has(id)),
          )
        }

        function undoLastAction() {
          if (!undoStack.length) return
          const previousPositions = capturePersonPositions()
          const entry = undoStack.pop()
          const currentSnapshot = snapshotPlannerState()
          redoStack.push({ description: entry.description, state: currentSnapshot })
          if (redoStack.length > HISTORY_LIMIT) {
            redoStack.shift()
          }
          applyStateSnapshot(entry.state)
          pendingAnimationPositions = previousPositions
          announceHistory(`Undid ${entry.description}`)
          saveState()
          render()
        }

        function redoLastAction() {
          if (!redoStack.length) return
          const previousPositions = capturePersonPositions()
          const entry = redoStack.pop()
          const currentSnapshot = snapshotPlannerState()
          undoStack.push({ description: entry.description, state: currentSnapshot })
          if (undoStack.length > HISTORY_LIMIT) {
            undoStack.shift()
          }
          applyStateSnapshot(entry.state)
          pendingAnimationPositions = previousPositions
          announceHistory(`Redid ${entry.description}`)
          saveState()
          render()
        }

        function handleHistoryShortcut(ev) {
          if (ev.defaultPrevented) return
          const key = typeof ev.key === 'string' ? ev.key.toLowerCase() : ''
          const isUndoShortcut = (ev.metaKey || ev.ctrlKey) && key === 'z' && !ev.altKey
          const isRedoShortcut =
            (ev.metaKey && key === 'z' && ev.shiftKey && !ev.altKey) ||
            (ev.ctrlKey && !ev.metaKey && key === 'y' && !ev.altKey)

          if (!isUndoShortcut && !isRedoShortcut) return

          const target = ev.target
          if (target) {
            const tag = target.tagName
            const isEditable =
              target.isContentEditable ||
              tag === 'INPUT' ||
              tag === 'TEXTAREA'
            if (isEditable) {
              return
            }
          }

          ev.preventDefault()
          if (isUndoShortcut) {
            undoLastAction()
          } else if (isRedoShortcut) {
            redoLastAction()
          }
        }

        function getDefaultTrackCapacity() {
          if (!state || typeof state.defaultTrackCapacity !== 'number') return 2
          if (state.defaultTrackCapacity < 1) return 1
          return state.defaultTrackCapacity
        }

        function addPeopleFromTextarea() {
          const textarea = document.getElementById('bulkNamesInput')
          if (!textarea) return
          const value = textarea.value || ''
          const lines = value
            .split(/\n+/)
            .map((l) => l.trim())
            .filter(Boolean)
          if (!lines.length) {
            alert('Please enter at least one name.')
            return
          }

          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          const description =
            lines.length === 1 ? `Add ${lines[0]}` : `Add ${lines.length} people`

          mutateState(description, () => {
            for (const name of lines) {
              const person = {
                id: 'p-' + state.nextPersonId++,
                name,
              }
              state.people.push(person)
              onDeck.personIds.push(person.id)
            }
            return true
          })

          textarea.value = ''
        }

        function resetPlan() {
          mutateState('Reset plan', () => {
            state = createInitialState()
            selectedTrackIds = new Set()
            return true
          })
        }

        function quickAddCapacityTrack(extraSlots) {
          const defaultCapacity = getDefaultTrackCapacity()
          let remaining = Math.max(defaultCapacity, extraSlots || defaultCapacity)
          const createdTrackIds = []

          while (remaining > 0) {
            const track = {
              id: 'track-' + state.nextTrackId++,
              name: `Extra Track ${state.nextTrackId - 1}`,
              type: 'normal',
              capacity: defaultCapacity,
              personIds: [],
            }
            state.tracks.push(track)
            createdTrackIds.push(track.id)
            remaining -= defaultCapacity
          }

          return createdTrackIds
        }

        function movePersonToTrackInternal(personId, targetTrackId) {
          const person = getPersonById(personId)
          const target = getTrackById(targetTrackId)
          if (!person || !target) return false
          if (!trackHasCapacity(target)) {
            return false
          }

          for (const track of state.tracks) {
            const idx = track.personIds.indexOf(personId)
            if (idx !== -1) {
              track.personIds.splice(idx, 1)
              break
            }
          }

          if (!target.personIds.includes(personId)) {
            target.personIds.push(personId)
          }

          return true
        }

        function movePersonToTrack(personId, targetTrackId, options = {}) {
          const person = getPersonById(personId)
          const target = getTrackById(targetTrackId)
          if (!person || !target) return false
          const description =
            options.description || `Move ${person.name} to ${target.name}`
          return mutateState(description, () =>
            movePersonToTrackInternal(personId, targetTrackId),
          )
        }

        function sweepTrackKeepOneInternal(track, onDeck) {
          if (!track) return false
          if (!onDeck) return false
          if (track.type === 'on_deck') return false
          if (track.personIds.length <= 1) return false

          const idxToKeep = Math.floor(Math.random() * track.personIds.length)
          const keepId = track.personIds[idxToKeep]
          const toMove = track.personIds.filter((id) => id !== keepId)

          track.personIds = [keepId]
          onDeck.personIds.push(...toMove)

          return true
        }

        function sweepTrackKeepOne(trackId) {
          const track = getTrackById(trackId)
          const onDeck = getTrackByType('on_deck')
          if (!track || !onDeck) return false
          const description = `Sweep ${track.name} (keep one)`
          return mutateState(description, () => sweepTrackKeepOneInternal(track, onDeck))
        }

        function sweepAllTracksKeepOne() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false
          return mutateState('Sweep all tracks (keep one)', () => {
            let changed = false
            for (const track of state.tracks) {
              if (track.type !== 'normal') continue
              if (sweepTrackKeepOneInternal(track, onDeck)) {
                changed = true
              }
            }
            return changed
          })
        }

        function sweepAndAllocateFromOnDeck() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck || !onDeck.personIds.length) return false

          return mutateState('Allocate from On Deck', () => {
            let normalTracks = state.tracks.filter((t) => t.type === 'normal')
            let changed = false

            if (!normalTracks.length) {
              const createdIds = quickAddCapacityTrack(onDeck.personIds.length)
              if (createdIds.length) {
                changed = true
              }
              normalTracks = state.tracks.filter((t) => t.type === 'normal')
            }

            if (!normalTracks.length) return false

            const onDeckCount = onDeck.personIds.length
            let totalAvailableSlots = 0
            let hasInfiniteCapacity = false
            for (const track of normalTracks) {
              if (track.capacity == null) {
                hasInfiniteCapacity = true
                break
              }
              const available = Math.max(0, track.capacity - track.personIds.length)
              totalAvailableSlots += available
            }

            if (!hasInfiniteCapacity && onDeckCount > 0 && totalAvailableSlots < onDeckCount) {
              const shortage = onDeckCount - totalAvailableSlots
              const createdIds = quickAddCapacityTrack(shortage)
              if (createdIds.length) {
                changed = true
              }
              normalTracks = state.tracks.filter((t) => t.type === 'normal')
            }

            const remaining = onDeck.personIds.slice()
            for (let i = remaining.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1))
              ;[remaining[i], remaining[j]] = [remaining[j], remaining[i]]
            }

            const originalOnDeckCount = onDeck.personIds.length
            for (const track of normalTracks) {
              if (!remaining.length) break
              const capacity = track.capacity == null ? Infinity : track.capacity
              let availableSlots = capacity - track.personIds.length
              while (availableSlots > 0 && remaining.length) {
                const id = remaining.pop()
                if (!id) break
                track.personIds.push(id)
                availableSlots--
                changed = true
              }
            }

            if (remaining.length !== originalOnDeckCount) {
              onDeck.personIds = remaining
              changed = true
            }

            return changed
          })
        }

        function deleteTrack(trackId) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false
          const description = `Delete track ${track.name}`
          return mutateState(description, () => {
            onDeck.personIds.push(...track.personIds)
            state.tracks = state.tracks.filter((t) => t.id !== trackId)
            selectedTrackIds.delete(trackId)
            return true
          })
        }

        function deleteAllTracks() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false

          const normalTracks = state.tracks.filter((t) => t.type === 'normal')
          if (!normalTracks.length) return false

          return mutateState(`Delete all ${normalTracks.length} track(s)`, () => {
            for (const track of normalTracks) {
              onDeck.personIds.push(...track.personIds)
            }

            state.tracks = state.tracks.filter((t) => t.type !== 'normal')
            selectedTrackIds.clear()
            return true
          })

        }

        function deleteSelectedTracks() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false

          const tracksToDelete = state.tracks.filter(
            (t) => t.type === 'normal' && selectedTrackIds.has(t.id),
          )
          if (!tracksToDelete.length) return false

          const description =
            tracksToDelete.length === 1
              ? `Delete track ${tracksToDelete[0].name}`
              : `Delete ${tracksToDelete.length} selected tracks`

          return mutateState(description, () => {
            for (const track of tracksToDelete) {
              onDeck.personIds.push(...track.personIds)
            }

            state.tracks = state.tracks.filter(
              (t) => !(t.type === 'normal' && selectedTrackIds.has(t.id)),
            )
            selectedTrackIds.clear()

            return true
          })
        }

        function updateTrackCapacity(trackId, newCapacity) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false

          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return false

          if (newCapacity != null && newCapacity < 1) {
            alert('Capacity must be at least 1.')
            return false
          }

          const description =
            newCapacity == null
              ? `Make ${track.name} capacity unlimited`
              : `Set ${track.name} capacity to ${newCapacity}`

          return mutateState(description, () => {
            let changed = false

            if (newCapacity == null) {
              if (track.capacity !== null) {
                track.capacity = null
                changed = true
              }
              return changed
            }

            if (track.capacity !== newCapacity) {
              track.capacity = newCapacity
              changed = true
            }

            if (track.personIds.length > newCapacity) {
              const overflow = track.personIds.splice(newCapacity)
              if (overflow.length) {
                onDeck.personIds.push(...overflow)
                changed = true
              }
            }

            return changed
          })
        }

        function updateTrackName(trackId, newName) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return false
          const trimmed = newName.trim()
          if (!trimmed || trimmed === track.name) return false
          const description = `Rename track to ${trimmed}`
          return mutateState(description, () => {
            track.name = trimmed
            return true
          })
        }

        function sweepPerson(personId) {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return
          movePersonToTrack(personId, onDeck.id)
        }

        function shufflePerson(personId) {
          const person = getPersonById(personId)
          if (!person) return false
          return mutateState(`Shuffle ${person.name}`, () => {
            const currentTrack = state.tracks.find((t) => t.personIds.includes(personId))
            if (!currentTrack) return false

            let candidates = state.tracks.filter((t) => {
              if (t.id === currentTrack.id) return false
              if (t.type === 'out_of_office') return false
              if (t.type === 'on_deck') return false
              return trackHasCapacity(t)
            })

            let changed = false

            if (!candidates.length) {
              const created = quickAddCapacityTrack(1)
              if (created.length) {
                changed = true
              }
              candidates = state.tracks.filter((t) => {
                if (t.id === currentTrack.id) return false
                if (t.type === 'out_of_office') return false
                if (t.type === 'on_deck') return false
                return trackHasCapacity(t)
              })
            }

            if (!candidates.length) {
              return changed
            }

            const idx = Math.floor(Math.random() * candidates.length)
            const target = candidates[idx]
            if (movePersonToTrackInternal(personId, target.id)) {
              changed = true
            }
            return changed
          })
        }

        function retirePerson(personId) {
          const person = getPersonById(personId)
          if (!person) return false
          return mutateState(`Retire ${person.name}`, () => {
            const originalCount = state.people.length
            state.people = state.people.filter((p) => p.id !== personId)
            if (state.people.length === originalCount) {
              return false
            }
            for (const track of state.tracks) {
              track.personIds = track.personIds.filter((id) => id !== personId)
            }
            pendingRetirePersonId = null
            return true
          })
        }

        function onDragStartPerson(ev, personId) {
          currentDragPersonId = personId
          ev.dataTransfer.effectAllowed = 'move'
          setDropZoneActive(true)
        }

        function onDragEndPerson() {
          currentDragPersonId = null
          const lists = document.querySelectorAll('.people-list')
          lists.forEach((el) => {
            el.classList.remove('drop-target')
          })
          setDropZoneActive(false)
        }

        function onDragOverList(ev, trackId) {
          if (!currentDragPersonId) return
          const track = getTrackById(trackId)
          if (!track || !trackHasCapacity(track)) return
          ev.preventDefault()
          ev.dataTransfer.dropEffect = 'move'
          const el = ev.currentTarget
          el.classList.add('drop-target')
        }

        function onDragLeaveList(ev) {
          const el = ev.currentTarget
          el.classList.remove('drop-target')
        }

        function onDropOnList(ev, trackId) {
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.remove('drop-target')
          if (!currentDragPersonId) return
          movePersonToTrack(currentDragPersonId, trackId)
          currentDragPersonId = null
          setDropZoneActive(false)
        }

        function onDragEnterDropZone(ev) {
          if (!currentDragPersonId) return
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.add('hover')
          if (ev.dataTransfer) {
            ev.dataTransfer.dropEffect = 'move'
          }
        }

        function onDragOverDropZone(ev) {
          if (!currentDragPersonId) return
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.add('hover')
          if (ev.dataTransfer) {
            ev.dataTransfer.dropEffect = 'move'
          }
        }

        function onDragLeaveDropZone(ev) {
          const el = ev.currentTarget
          el.classList.remove('hover')
        }

        function onDropOnDropZone(ev) {
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.remove('hover')
          if (!currentDragPersonId) return
          const personId = currentDragPersonId
          currentDragPersonId = null
          createTrackFromPersonDrop(personId)
          setDropZoneActive(false)
        }

        function render() {
          const container = document.getElementById('tracksContainer')
          if (!container) return
          clearObsoleteTrackSelections()
          container.innerHTML = ''

          const defaultCapacityInput = document.getElementById('defaultCapacityInput')
          if (defaultCapacityInput) {
            defaultCapacityInput.value = String(getDefaultTrackCapacity())
          }

          const deleteSelectedTracksButton = document.getElementById('deleteSelectedTracksButton')
          if (deleteSelectedTracksButton) {
            const hasSelected = Array.from(selectedTrackIds).some((id) => {
              const t = getTrackById(id)
              return t && t.type === 'normal'
            })
            deleteSelectedTracksButton.disabled = !hasSelected
          }

          const sweepAllTracksButton = document.getElementById('sweepAllTracksButton')
          if (sweepAllTracksButton) {
            const canSweepAny = state.tracks.some(
              (t) => t.type === 'normal' && t.personIds.length > 1,
            )
            sweepAllTracksButton.disabled = !canSweepAny
          }

          const deleteAllTracksButton = document.getElementById('deleteAllTracksButton')
          if (deleteAllTracksButton) {
            const hasAnyNormalTrack = state.tracks.some((t) => t.type === 'normal')
            deleteAllTracksButton.disabled = !hasAnyNormalTrack
          }

          const capacityNotice = document.getElementById('capacityNotice')
          if (capacityNotice) {
            capacityNotice.innerHTML = ''
            const normalTracks = state.tracks.filter((t) => t.type === 'normal')
            const anyHasCapacity = normalTracks.some((t) => trackHasCapacity(t))
            const onDeck = getTrackByType('on_deck')
            const onDeckCount = onDeck ? onDeck.personIds.length : 0

            let totalAvailableSlots = 0
            let hasInfiniteCapacity = false
            for (const track of normalTracks) {
              if (track.capacity == null) {
                hasInfiniteCapacity = true
                break
              }
              const available = Math.max(0, track.capacity - track.personIds.length)
              totalAvailableSlots += available
            }

            let shortage = 0
            if (!hasInfiniteCapacity && onDeckCount > 0 && totalAvailableSlots < onDeckCount) {
              shortage = onDeckCount - totalAvailableSlots
            }

            if (shortage > 0) {
              const text = document.createElement('span')
              const defaultCap = getDefaultTrackCapacity()
              text.textContent = `Not enough track capacity: ${onDeckCount} on deck but only ${totalAvailableSlots} open slot${totalAvailableSlots === 1 ? '' : 's'}. Allocating will automatically create extra tracks (capacity ${defaultCap}) until everyone fits.`
              capacityNotice.appendChild(text)
            } else if (normalTracks.length && !anyHasCapacity) {
              const text = document.createElement('span')
              text.textContent =
                'All tracks are at capacity; shuffle and drag are disabled until space is freed.'
              capacityNotice.appendChild(text)
            }
          }

          for (const track of state.tracks) {
            const trackEl = document.createElement('section')
            trackEl.className = 'track'
            trackEl.dataset.trackId = track.id

            const header = document.createElement('div')
            header.className = 'track-header'

            const headerRow = document.createElement('div')
            headerRow.className = 'track-header-row'

            if (track.type === 'normal') {
              const selectCheckbox = document.createElement('input')
              selectCheckbox.type = 'checkbox'
              selectCheckbox.className = 'track-select-checkbox'
              selectCheckbox.checked = selectedTrackIds.has(track.id)
              selectCheckbox.title = 'Select track for batch delete'
              selectCheckbox.addEventListener('change', (ev) => {
                if (ev.target.checked) {
                  selectedTrackIds.add(track.id)
                } else {
                  selectedTrackIds.delete(track.id)
                }
                render()
              })
              headerRow.appendChild(selectCheckbox)
            }

            const titleSpan = document.createElement('span')
            titleSpan.className = 'track-title'
            titleSpan.textContent = track.name

            if (track.type === 'normal') {
              titleSpan.style.cursor = 'pointer'
              titleSpan.title = 'Click to rename track'
              titleSpan.addEventListener('click', () => {
                const newName = prompt('New track name?', track.name)
                if (!newName) return
                updateTrackName(track.id, newName)
              })
            }

            headerRow.appendChild(titleSpan)

            if (track.type !== 'normal') {
              const badge = document.createElement('span')
              badge.className = 'badge'
              const dot = document.createElement('span')
              dot.className = 'badge-dot'
              badge.appendChild(dot)
              const label = document.createElement('span')
              label.textContent = track.type === 'on_deck' ? 'On Deck' : 'Out of Office'
              badge.appendChild(label)
              headerRow.appendChild(badge)
            }

            header.appendChild(headerRow)

            const metaRow = document.createElement('div')
            metaRow.className = 'track-meta'

            const countSpan = document.createElement('span')
            const assigned = track.personIds.length
            const capacityLabel =
              track.capacity == null ? '∞' : String(track.capacity)
            countSpan.textContent =
              track.capacity == null
                ? `${assigned} assigned`
                : `${assigned} / ${capacityLabel} assigned`
            metaRow.appendChild(countSpan)

            const isFull =
              track.type === 'normal' &&
              track.capacity != null &&
              assigned >= track.capacity

            if (track.type === 'normal') {
              const capWrapper = document.createElement('div')
              const capLabel = document.createElement('span')
              capLabel.textContent = 'Capacity: '
              capLabel.className = 'muted'
              const capInput = document.createElement('input')
              capInput.type = 'number'
              capInput.min = '1'
              capInput.className = 'capacity-input'
              if (track.capacity != null) {
                capInput.value = String(track.capacity)
              } else {
                capInput.value = ''
              }
              capInput.placeholder = '∞'
              capInput.addEventListener('change', (ev) => {
                const value = ev.target.value.trim()
                if (!value) {
                  updateTrackCapacity(track.id, null)
                } else {
                  const parsed = Number(value)
                  if (Number.isNaN(parsed)) {
                    render()
                  } else {
                    updateTrackCapacity(track.id, parsed)
                  }
                }
              })
              capWrapper.appendChild(capLabel)
              capWrapper.appendChild(capInput)
              metaRow.appendChild(capWrapper)

              if (isFull) {
                const fullLabel = document.createElement('span')
                fullLabel.className = 'track-type'
                fullLabel.textContent = 'Full'
                metaRow.appendChild(fullLabel)
                trackEl.classList.add('track-full')
              }
            } else {
              const typeLabel = document.createElement('span')
              typeLabel.className = 'track-type'
              typeLabel.textContent =
                track.type === 'on_deck' ? 'Source pool' : 'Unavailable'
              metaRow.appendChild(typeLabel)
            }

            header.appendChild(metaRow)

            const actionsRow = document.createElement('div')
            actionsRow.className = 'track-actions'

            if (track.type === 'on_deck') {
              const sweepAllocBtn = document.createElement('button')
              sweepAllocBtn.textContent = 'Allocate to tracks'
              sweepAllocBtn.className = 'primary'
              sweepAllocBtn.disabled = !track.personIds.length
              sweepAllocBtn.addEventListener('click', () => {
                sweepAndAllocateFromOnDeck()
              })
              actionsRow.appendChild(sweepAllocBtn)
            } else if (track.type === 'normal') {
              const sweepBtn = document.createElement('button')
              sweepBtn.textContent = '⬅️ Sweep (keep one)'
              sweepBtn.title = 'Sweep everyone but one back to On Deck'
              sweepBtn.className = 'primary'
              sweepBtn.addEventListener('click', () => {
                sweepTrackKeepOne(track.id)
              })
              sweepBtn.disabled = track.personIds.length <= 1
              actionsRow.appendChild(sweepBtn)
            }

            if (track.type === 'normal') {
              const deleteBtn = document.createElement('button')
              deleteBtn.textContent = 'Delete track'
              deleteBtn.className = 'danger'
              deleteBtn.addEventListener('click', () => {
                deleteTrack(track.id)
              })
              actionsRow.appendChild(deleteBtn)
            }

            header.appendChild(actionsRow)

            trackEl.appendChild(header)

            const peopleList = document.createElement('div')
            peopleList.className =
              'people-list' + (track.personIds.length ? '' : ' empty')
            peopleList.dataset.trackId = track.id
            peopleList.addEventListener('dragover', (ev) =>
              onDragOverList(ev, track.id),
            )
            peopleList.addEventListener('dragleave', onDragLeaveList)
            peopleList.addEventListener('drop', (ev) =>
              onDropOnList(ev, track.id),
            )

            if (!track.personIds.length) {
              const empty = document.createElement('span')
              empty.className = 'muted'
              empty.textContent = 'Empty'
              peopleList.appendChild(empty)
            } else {
              for (const personId of track.personIds) {
                const person = getPersonById(personId)
                if (!person) continue
                const personEl = document.createElement('div')
                personEl.className = 'person'
                personEl.dataset.personId = person.id
                personEl.draggable = true
                personEl.addEventListener('dragstart', (ev) =>
                  onDragStartPerson(ev, person.id),
                )
                personEl.addEventListener('dragend', onDragEndPerson)

                const nameSpan = document.createElement('span')
                nameSpan.className = 'person-name'
                nameSpan.textContent = person.name
                nameSpan.style.cursor = 'pointer'
                nameSpan.title = 'Click to rename person'
                nameSpan.addEventListener('click', () => {
                  const newName = prompt('New name?', person.name)
                  if (!newName) return
                  updatePersonName(person.id, newName)
                })
                personEl.appendChild(nameSpan)

                const actions = document.createElement('div')
                actions.className = 'person-actions'

                const isPendingRetire = pendingRetirePersonId === person.id

                if (isPendingRetire) {
                  personEl.classList.add('person-pending-retire')
                }

                if (!isPendingRetire) {
                  const shuffleBtn = document.createElement('button')
                  shuffleBtn.textContent = '🔀'
                  shuffleBtn.title = 'Shuffle to another track'
                  shuffleBtn.className = 'primary'
                  shuffleBtn.dataset.label = 'Shuffle'
                  shuffleBtn.addEventListener('click', () => {
                    shufflePerson(person.id)
                  })
                  actions.appendChild(shuffleBtn)

                  if (track.type !== 'on_deck') {
                    const sweepBtn = document.createElement('button')
                    sweepBtn.textContent = '⬅️'
                    sweepBtn.title = 'Sweep to On Deck'
                    sweepBtn.addEventListener('click', () => {
                      sweepPerson(person.id)
                    })
                    actions.appendChild(sweepBtn)
                  }

                  const moveCandidates = state.tracks.filter((t) => {
                    if (t.id === track.id) return false
                    if (t.type === 'out_of_office') return false
                    return trackHasCapacity(t)
                  })

                  const moveSelect = document.createElement('select')
                  moveSelect.setAttribute('aria-label', 'Move to track')

                  const placeholderOption = document.createElement('option')
                  placeholderOption.value = ''
                  placeholderOption.textContent = 'Move…'
                  placeholderOption.disabled = true
                  placeholderOption.selected = true
                  moveSelect.appendChild(placeholderOption)

                  for (const t of moveCandidates) {
                    const opt = document.createElement('option')
                    opt.value = t.id
                    opt.textContent = t.name
                    moveSelect.appendChild(opt)
                  }

                  const newTrackOption = document.createElement('option')
                  newTrackOption.value = NEW_TRACK_OPTION_VALUE
                  newTrackOption.textContent = '➕ New track…'
                  moveSelect.appendChild(newTrackOption)

                  moveSelect.addEventListener('change', (ev) => {
                    const targetId = ev.target.value
                    if (!targetId) return
                    if (targetId === NEW_TRACK_OPTION_VALUE) {
                      createTrackFromPersonDrop(person.id)
                      return
                    }
                    movePersonToTrack(person.id, targetId)
                  })

                  actions.appendChild(moveSelect)
                }

                const retireBtn = document.createElement('button')
                if (isPendingRetire) {
                  retireBtn.textContent = '✅'
                  retireBtn.className = 'danger'
                  retireBtn.title = `Confirm retire ${person.name}`
                } else {
                  retireBtn.textContent = '👋'
                  retireBtn.className = 'retire-button'
                  retireBtn.title = 'Retire from planner'
                }
                retireBtn.addEventListener('click', () => {
                  if (pendingRetirePersonId === person.id) {
                    retirePerson(person.id)
                  } else {
                    pendingRetirePersonId = person.id
                    render()
                  }
                })
                actions.appendChild(retireBtn)

                if (isPendingRetire) {
                  const cancelRetireBtn = document.createElement('button')
                  cancelRetireBtn.textContent = '✖️'
                  cancelRetireBtn.title = 'Cancel'
                  cancelRetireBtn.addEventListener('click', () => {
                    pendingRetirePersonId = null
                    render()
                  })
                  actions.appendChild(cancelRetireBtn)
                }

                personEl.appendChild(actions)
                peopleList.appendChild(personEl)
              }
            }

            trackEl.appendChild(peopleList)
            container.appendChild(trackEl)
          }

          const dropZone = document.createElement('div')
          dropZone.id = 'createTrackDropZone'
          dropZone.className = 'create-track-drop-zone'
          dropZone.textContent = 'Drop to create a new track'
          dropZone.setAttribute('role', 'button')
          dropZone.setAttribute('aria-hidden', currentDragPersonId ? 'false' : 'true')
          dropZone.setAttribute('aria-label', 'Drop to create a new track')
          dropZone.addEventListener('dragenter', onDragEnterDropZone)
          dropZone.addEventListener('dragover', onDragOverDropZone)
          dropZone.addEventListener('dragleave', onDragLeaveDropZone)
          dropZone.addEventListener('drop', onDropOnDropZone)
          if (currentDragPersonId) {
            dropZone.classList.add('visible')
          }

          container.appendChild(dropZone)
          updateHistoryControls()
          playPendingAnimation()
          flushHistoryAnnouncement()
        }

        function init() {
          state = loadState()

          historyAnnouncerEl = document.getElementById('historyAnnouncer')

          undoButtonEl = document.getElementById('undoButton')
          if (undoButtonEl) {
            undoButtonEl.addEventListener('click', (ev) => {
              ev.preventDefault()
              undoLastAction()
            })
          }

          redoButtonEl = document.getElementById('redoButton')
          if (redoButtonEl) {
            redoButtonEl.addEventListener('click', (ev) => {
              ev.preventDefault()
              redoLastAction()
            })
          }

          if (!historyShortcutBound) {
            document.addEventListener('keydown', handleHistoryShortcut)
            historyShortcutBound = true
          }

          const addPeopleButton = document.getElementById('addPeopleButton')
          if (addPeopleButton) {
            addPeopleButton.addEventListener('click', addPeopleFromTextarea)
          }

          const resetPlanButton = document.getElementById('resetPlanButton')
          if (resetPlanButton) {
            resetPlanButton.addEventListener('click', resetPlan)
          }

          const deleteSelectedTracksButton = document.getElementById('deleteSelectedTracksButton')
          if (deleteSelectedTracksButton) {
            deleteSelectedTracksButton.addEventListener('click', () => {
              deleteSelectedTracks()
            })
          }

          const sweepAllTracksButton = document.getElementById('sweepAllTracksButton')
          if (sweepAllTracksButton) {
            sweepAllTracksButton.addEventListener('click', () => {
              sweepAllTracksKeepOne()
            })
          }

          const deleteAllTracksButton = document.getElementById('deleteAllTracksButton')
          if (deleteAllTracksButton) {
            deleteAllTracksButton.addEventListener('click', () => {
              deleteAllTracks()
            })
          }

          const defaultCapacityInput = document.getElementById('defaultCapacityInput')
          if (defaultCapacityInput) {
            defaultCapacityInput.addEventListener('change', (ev) => {
              const raw = ev.target.value.trim()
              let value = Number(raw)
              if (!raw || Number.isNaN(value) || value < 1) {
                value = 2
              }
              if (state.defaultTrackCapacity === value) {
                defaultCapacityInput.value = String(value)
                return
              }
              mutateState(`Set default track capacity to ${value}`, () => {
                state.defaultTrackCapacity = value
                return true
              })
            })
          }

          render()
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init)
        } else {
          init()
        }
      })()
    </script>
  </body>
</html>
