<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mobbist</title>
    <style>
      :root {
        --bg: #f4f4f4;
        --card-bg: #ffffff;
        --border: #dddddd;
        --accent: #0070f3;
        --accent-soft: #e3f1ff;
        --danger: #b3261e;
        --muted: #666666;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        margin: 24px;
        background: var(--bg);
        color: #111827;
      }

      h1 {
        margin: 0 0 4px;
        font-size: 1.6rem;
      }

      p {
        margin: 0 0 12px;
        color: var(--muted);
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
      }

      .layout-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 16px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      textarea {
        width: 100%;
        min-height: 80px;
        padding: 8px;
        font-size: 14px;
        resize: vertical;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
      }

      button {
        padding: 6px 12px;
        cursor: pointer;
        font-size: 13px;
        border-radius: 4px;
        border: 1px solid var(--border);
        background: #ffffff;
        color: #111827;
      }

      button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #ffffff;
      }

      button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: #ffffff;
      }

      button.ghost {
        background: transparent;
      }

      button:disabled {
        opacity: 0.5;
        cursor: default;
      }

      .tracks-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 8px 0 12px;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tracks-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 12px;
        align-items: flex-start;
      }

      .create-track-drop-zone {
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        border: 2px dashed var(--accent);
        border-radius: 6px;
        background: var(--accent-soft);
        color: var(--accent);
        font-weight: 600;
        min-height: 96px;
        transition: background 120ms ease, color 120ms ease, border-color 120ms ease;
      }

      .create-track-drop-zone.visible {
        display: flex;
      }

      .create-track-drop-zone.hover {
        background: var(--accent);
        color: #ffffff;
        border-color: var(--accent);
      }

      .track {
        background: var(--card-bg);
        border-radius: 6px;
        border: 1px solid var(--border);
        padding: 8px;
        display: flex;
        flex-direction: column;
        min-height: 120px;
      }

      .track-header {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 6px;
      }

      .track-header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        min-width: 0;
      }

      .track-title {
        font-weight: 600;
        font-size: 0.95rem;
        word-break: break-word;
        overflow-wrap: anywhere;
        min-width: 0;
      }

      .track-type {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }

      .track-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        font-size: 0.75rem;
      }

      .capacity-input {
        width: 60px;
        padding: 3px 4px;
        font-size: 0.75rem;
      }

      .track-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }

      .people-list {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 4px;
        border-radius: 4px;
        background: #f9fafb;
        min-height: 60px;
        max-height: 260px;
        overflow-y: auto;
      }

      .people-list.empty {
        font-size: 0.8rem;
        color: var(--muted);
        align-items: center;
        justify-content: center;
        display: flex;
      }

      .people-list.drop-target {
        outline: 2px dashed var(--accent);
        background: var(--accent-soft);
      }

      .person {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 6px;
        flex-wrap: wrap;
        padding: 4px 6px;
        border-radius: 4px;
        background: #ffffff;
        border: 1px solid var(--border);
        font-size: 0.85rem;
      }

      .person-name {
        flex: 1 1 auto;
        word-break: break-word;
        overflow-wrap: anywhere;
        min-width: 0;
      }

      .person-actions {
        display: flex;
        gap: 2px;
        flex-wrap: wrap;
        justify-content: flex-start;
        flex: 0 0 auto;
      }

      .person-actions button {
        padding: 2px 6px;
        font-size: 0.7rem;
      }

      .person-actions .retire-button {
        border-color: var(--danger);
        color: var(--danger);
        background: #fef2f2;
        margin-left: 8px;
      }

      .person-actions .danger {
        margin-left: 8px;
      }

      .person-pending-retire {
        background: #fef2f2;
      }

      .person-pending-retire .person-name::after {
        content: ' (retiringâ€¦)';
        font-size: 0.75rem;
        color: var(--danger);
      }

      .person-actions select {
        padding: 2px 4px;
        font-size: 0.7rem;
        max-width: 80px;
      }

      @media (min-width: 768px) {
        .person-actions button[data-label]::after {
          content: ' ' attr(data-label);
        }
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e5e7eb;
        font-size: 0.7rem;
      }

      .badge-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--accent);
        margin-right: 4px;
      }

      .muted {
        color: var(--muted);
      }

      .track-full {
        border-color: #f97316;
      }

      @media (max-width: 600px) {
        body {
          margin: 12px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="layout-header">
        <div>
          <h1>Mobbist</h1>
          <p>Plan pairs and mobs and reshuffle people quickly in your browser.</p>
        </div>
        <div class="controls">
          <button id="resetPlanButton" class="ghost">Reset plan</button>
        </div>
      </div>

      <section class="stack">
        <label for="bulkNamesInput" style="font-size:0.85rem;">Add people (one name per line):</label>
        <textarea
          id="bulkNamesInput"
          placeholder="Alice&#10;Bob&#10;Charlie&#10;Dana"
        ></textarea>
        <div>
          <button id="addPeopleButton" class="primary">Add people to On Deck</button>
        </div>
      </section>

      <section class="tracks-toolbar">
        <div class="muted" style="font-size:0.8rem;">
          Tracks: On Deck distributes into all normal tracks. Out of Office is excluded from random allocation.
        </div>
        <div class="muted" style="font-size:0.75rem; display:flex; align-items:center; gap:4px; flex-wrap:wrap;">
           <label for="defaultCapacityInput">Default capacity:</label>
            <input id="defaultCapacityInput" type="number" min="1" value="2" style="width:3rem; padding:2px 4px; font-size:0.75rem;" />
            <button id="sweepAllTracksButton" disabled>Sweep all tracks</button>
            <button id="deleteSelectedTracksButton" class="danger" disabled>Delete selected tracks</button>
            <button id="deleteAllTracksButton" class="danger" disabled>Delete all tracks</button>
         </div>
         <div id="capacityNotice" class="muted" style="font-size:0.75rem;"></div>


      </section>

      <section id="tracksContainer" class="tracks-grid" aria-label="Tracks"></section>
    </main>

    <script>
      ;(function () {
        const STORAGE_KEY = 'mobbist:v1'
        const LEGACY_STORAGE_KEYS = ['pairPlanner:v1']
        const NEW_TRACK_OPTION_VALUE = '__create_new_track__'

        /**
         * @typedef {{ id: string, name: string }} Person
         * @typedef {{ id: string, name: string, type: 'normal' | 'on_deck' | 'out_of_office', capacity: number | null, personIds: string[] }} Track
         * @typedef {{ people: Person[], tracks: Track[], nextPersonId: number, nextTrackId: number, defaultTrackCapacity: number }} PlannerState
         */

        /** @type {PlannerState} */
        let state
        let currentDragPersonId = null
        let pendingRetirePersonId = null
        let pendingDeleteTrackId = null
        /** @type {Set<string>} */
        let selectedTrackIds = new Set()

        function createInitialState() {
          return {
            people: [],
            tracks: [
              {
                id: 'on_deck',
                name: 'On Deck',
                type: 'on_deck',
                capacity: null,
                personIds: [],
              },
              {
                id: 'out_of_office',
                name: 'Out of Office',
                type: 'out_of_office',
                capacity: null,
                personIds: [],
              },
              {
                id: 'track-1',
                name: 'Track A',
                type: 'normal',
                capacity: 2,
                personIds: [],
              },
            ],
            nextPersonId: 1,
            nextTrackId: 2,
            defaultTrackCapacity: 2,
          }
        }

        function loadState() {
          try {
            let raw = window.localStorage.getItem(STORAGE_KEY)
            if (!raw) {
              for (const legacyKey of LEGACY_STORAGE_KEYS) {
                raw = window.localStorage.getItem(legacyKey)
                if (raw) break
              }
            }
            if (!raw) return createInitialState()
            const parsed = JSON.parse(raw)
            if (!parsed || !Array.isArray(parsed.people) || !Array.isArray(parsed.tracks)) {
              return createInitialState()
            }
            if (typeof parsed.nextPersonId !== 'number') parsed.nextPersonId = 1
            if (typeof parsed.nextTrackId !== 'number') parsed.nextTrackId = 1
            if (typeof parsed.defaultTrackCapacity !== 'number' || parsed.defaultTrackCapacity < 1) {
              parsed.defaultTrackCapacity = 2
            }
            return parsed
          } catch (e) {
            console.warn('Failed to load planner state, resetting.', e)
            return createInitialState()
          }
        }

        function saveState() {
          try {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
          } catch (e) {
            console.warn('Failed to save planner state.', e)
          }
        }

        function getTrackByType(type) {
          return state.tracks.find((t) => t.type === type) || null
        }

        function getTrackById(id) {
          return state.tracks.find((t) => t.id === id) || null
        }

        function getPersonById(id) {
          return state.people.find((p) => p.id === id) || null
        }

        function updatePersonName(personId, newName) {
          const person = getPersonById(personId)
          if (!person) return
          const trimmed = newName.trim()
          if (!trimmed) return
          person.name = trimmed
          saveState()
          render()
        }

        function trackHasCapacity(track) {
          if (track.capacity == null) return true
          return track.personIds.length < track.capacity
        }

        function generateAutomaticTrackName(counter = state.nextTrackId) {
          const letterIndex = counter
          if (letterIndex >= 1 && letterIndex <= 26) {
            return `Track ${String.fromCharCode(64 + letterIndex)}`
          }
          return `Track ${letterIndex}`
        }

        function setDropZoneActive(active) {
          const dropZone = document.getElementById('createTrackDropZone')
          if (!dropZone) return
          if (active) {
            dropZone.classList.add('visible')
            dropZone.setAttribute('aria-hidden', 'false')
          } else {
            dropZone.classList.remove('visible')
            dropZone.classList.remove('hover')
            dropZone.setAttribute('aria-hidden', 'true')
          }
        }

        function createTrackFromPersonDrop(personId) {
          const person = getPersonById(personId)
          if (!person) return

          const sourceTrack = state.tracks.find((t) => t.personIds.includes(personId))
          if (sourceTrack) {
            sourceTrack.personIds = sourceTrack.personIds.filter((id) => id !== personId)
          }

          const trackCounter = state.nextTrackId++
          const newTrackId = 'track-' + trackCounter
          const trackName = generateAutomaticTrackName(trackCounter)
          const newTrack = {
            id: newTrackId,
            name: trackName,
            type: 'normal',
            capacity: null,
            personIds: [personId],
          }

          state.tracks.push(newTrack)
          saveState()
          render()
        }

        function getDefaultTrackCapacity() {
          if (!state || typeof state.defaultTrackCapacity !== 'number') return 2
          if (state.defaultTrackCapacity < 1) return 1
          return state.defaultTrackCapacity
        }

        function addPeopleFromTextarea() {
          const textarea = document.getElementById('bulkNamesInput')
          if (!textarea) return
          const value = textarea.value || ''
          const lines = value
            .split(/\n+/)
            .map((l) => l.trim())
            .filter(Boolean)
          if (!lines.length) {
            alert('Please enter at least one name.')
            return
          }

          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          for (const name of lines) {
            const person = {
              id: 'p-' + state.nextPersonId++,
              name,
            }
            state.people.push(person)
            onDeck.personIds.push(person.id)
          }

          textarea.value = ''
          saveState()
          render()
        }

        function resetPlan() {
          if (!confirm('Reset plan? This will clear all tracks and people for this tool on this browser.')) {
            return
          }
          window.localStorage.removeItem(STORAGE_KEY)
          state = createInitialState()
          selectedTrackIds.clear()
          render()
        }

        function quickAddCapacityTrack(extraSlots) {
          const defaultCapacity = getDefaultTrackCapacity()
          let remaining = Math.max(defaultCapacity, extraSlots || defaultCapacity)

          while (remaining > 0) {
            const track = {
              id: 'track-' + state.nextTrackId++,
              name: `Extra Track ${state.nextTrackId - 1}`,
              type: 'normal',
              capacity: defaultCapacity,
              personIds: [],
            }
            state.tracks.push(track)
            remaining -= defaultCapacity
          }

          saveState()
          render()
        }

        function movePersonToTrack(personId, targetTrackId) {
          const person = getPersonById(personId)
          const target = getTrackById(targetTrackId)
          if (!person || !target) return

          if (!trackHasCapacity(target)) {
            return
          }

          let currentTrack = null
          for (const track of state.tracks) {
            const idx = track.personIds.indexOf(personId)
            if (idx !== -1) {
              currentTrack = track
              track.personIds.splice(idx, 1)
              break
            }
          }

          // Avoid duplicate if we somehow didn't find original track.
          if (!target.personIds.includes(personId)) {
            target.personIds.push(personId)
          }

          saveState()
          render()
        }

        function sweepTrackKeepOneInternal(track, onDeck) {
          if (!track) return false
          if (!onDeck) return false
          if (track.type === 'on_deck') return false
          if (track.personIds.length <= 1) return false

          const idxToKeep = Math.floor(Math.random() * track.personIds.length)
          const keepId = track.personIds[idxToKeep]
          const toMove = track.personIds.filter((id) => id !== keepId)

          track.personIds = [keepId]
          onDeck.personIds.push(...toMove)

          return true
        }

        function sweepTrackKeepOne(trackId) {
          const track = getTrackById(trackId)
          const onDeck = getTrackByType('on_deck')
          if (!track || !onDeck) return

          if (!sweepTrackKeepOneInternal(track, onDeck)) return

          saveState()
          render()
        }

        function sweepAllTracksKeepOne() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          let changed = false
          for (const track of state.tracks) {
            if (track.type !== 'normal') continue
            if (sweepTrackKeepOneInternal(track, onDeck)) {
              changed = true
            }
          }

          if (!changed) return

          saveState()
          render()
        }

        function sweepAndAllocateFromOnDeck() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck || !onDeck.personIds.length) return

          let normalTracks = state.tracks.filter((t) => t.type === 'normal')

          // If there are no normal tracks yet, create enough new ones
          // (using the default capacity) so everyone on deck can be placed.
          if (!normalTracks.length) {
            const onDeckCount = onDeck.personIds.length
            if (onDeckCount > 0) {
              quickAddCapacityTrack(onDeckCount)
              normalTracks = state.tracks.filter((t) => t.type === 'normal')
            }
          }

          if (!normalTracks.length) return

          // If there isn't enough capacity, automatically create extra tracks.
          const onDeckCount = onDeck.personIds.length
          let totalAvailableSlots = 0
          let hasInfiniteCapacity = false
          for (const track of normalTracks) {
            if (track.capacity == null) {
              hasInfiniteCapacity = true
              break
            }
            const available = Math.max(0, track.capacity - track.personIds.length)
            totalAvailableSlots += available
          }

          if (!hasInfiniteCapacity && onDeckCount > 0 && totalAvailableSlots < onDeckCount) {
            const shortage = onDeckCount - totalAvailableSlots
            quickAddCapacityTrack(shortage)
            // Recompute tracks to include the new ones.
            normalTracks = state.tracks.filter((t) => t.type === 'normal')
          }

          // Create a shuffled copy of on deck people
          const remaining = onDeck.personIds.slice()
          for (let i = remaining.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1))
            ;[remaining[i], remaining[j]] = [remaining[j], remaining[i]]
          }

          for (const track of normalTracks) {
            if (!remaining.length) break
            const capacity = track.capacity == null ? Infinity : track.capacity
            let availableSlots = capacity - track.personIds.length
            while (availableSlots > 0 && remaining.length) {
              const id = remaining.pop()
              if (!id) break
              track.personIds.push(id)
              availableSlots--
            }
          }

          onDeck.personIds = remaining

          saveState()
          render()
        }

        function deleteTrack(trackId) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          onDeck.personIds.push(...track.personIds)
          state.tracks = state.tracks.filter((t) => t.id !== trackId)
          selectedTrackIds.delete(trackId)
          if (pendingDeleteTrackId === trackId) {
            pendingDeleteTrackId = null
          }

          saveState()
          render()
        }

        function deleteAllTracks() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          const normalTracks = state.tracks.filter((t) => t.type === 'normal')
          if (!normalTracks.length) return

          if (
            !confirm(
              `Delete all ${normalTracks.length} normal track${normalTracks.length === 1 ? '' : 's'}? All people on these tracks will be moved back to On Deck.`,
            )
          ) {
            return
          }

          for (const track of normalTracks) {
            onDeck.personIds.push(...track.personIds)
          }

          state.tracks = state.tracks.filter((t) => t.type !== 'normal')
          selectedTrackIds.clear()
          pendingDeleteTrackId = null

          saveState()
          render()
        }

        function deleteSelectedTracks() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          const tracksToDelete = state.tracks.filter(
            (t) => t.type === 'normal' && selectedTrackIds.has(t.id),
          )
          if (!tracksToDelete.length) return

          const names = tracksToDelete.map((t) => `"${t.name}"`).join(', ')
          if (
            !confirm(
              `Delete ${tracksToDelete.length} track${tracksToDelete.length === 1 ? '' : 's'} (${names})? All people on these tracks will be moved back to On Deck.`,
            )
          ) {
            return
          }

          for (const track of tracksToDelete) {
            onDeck.personIds.push(...track.personIds)
          }

          state.tracks = state.tracks.filter(
            (t) => !(t.type === 'normal' && selectedTrackIds.has(t.id)),
          )
          selectedTrackIds.clear()

          saveState()
          render()
        }

        function updateTrackCapacity(trackId, newCapacity) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return

          const originalCapacity = track.capacity
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          if (newCapacity == null) {
            track.capacity = null
          } else if (newCapacity < 1) {
            alert('Capacity must be at least 1.')
            return
          } else {
            if (track.personIds.length > newCapacity) {
              const overflowCount = track.personIds.length - newCapacity
              if (
                !confirm(
                  `${overflowCount} people will be moved back to On Deck. Continue?`,
                )
              ) {
                // Re-render to reset any partial input state.
                render()
                return
              }
              const overflow = track.personIds.splice(newCapacity)
              onDeck.personIds.push(...overflow)
            }
            track.capacity = newCapacity
          }

          if (track.capacity !== originalCapacity) {
            saveState()
            render()
          }
        }

        function updateTrackName(trackId, newName) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return
          const trimmed = newName.trim()
          if (!trimmed) return
          track.name = trimmed
          saveState()
          // No need to re-render for a simple inline update, but keep it consistent.
          render()
        }

        function sweepPerson(personId) {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return
          movePersonToTrack(personId, onDeck.id)
        }

        function shufflePerson(personId) {
          const currentTrack = state.tracks.find((t) => t.personIds.includes(personId))
          if (!currentTrack) return

          let candidates = state.tracks.filter((t) => {
            if (t.id === currentTrack.id) return false
            if (t.type === 'out_of_office') return false
            if (t.type === 'on_deck') return false
            return trackHasCapacity(t)
          })

          if (!candidates.length) {
            // No existing track has capacity; create just enough slots
            // for the person being shuffled, then try again.
            quickAddCapacityTrack(1)
            candidates = state.tracks.filter((t) => {
              if (t.id === currentTrack.id) return false
              if (t.type === 'out_of_office') return false
              if (t.type === 'on_deck') return false
              return trackHasCapacity(t)
            })
          }

          if (!candidates.length) {
            return
          }

          const idx = Math.floor(Math.random() * candidates.length)
          const target = candidates[idx]
          movePersonToTrack(personId, target.id)
        }

        function retirePerson(personId) {
          const person = getPersonById(personId)
          if (!person) return
          state.people = state.people.filter((p) => p.id !== personId)
          for (const track of state.tracks) {
            track.personIds = track.personIds.filter((id) => id !== personId)
          }

          pendingRetirePersonId = null
          saveState()
          render()
        }

        function onDragStartPerson(ev, personId) {
          currentDragPersonId = personId
          ev.dataTransfer.effectAllowed = 'move'
          setDropZoneActive(true)
        }

        function onDragEndPerson() {
          currentDragPersonId = null
          const lists = document.querySelectorAll('.people-list')
          lists.forEach((el) => {
            el.classList.remove('drop-target')
          })
          setDropZoneActive(false)
        }

        function onDragOverList(ev, trackId) {
          if (!currentDragPersonId) return
          const track = getTrackById(trackId)
          if (!track || !trackHasCapacity(track)) return
          ev.preventDefault()
          ev.dataTransfer.dropEffect = 'move'
          const el = ev.currentTarget
          el.classList.add('drop-target')
        }

        function onDragLeaveList(ev) {
          const el = ev.currentTarget
          el.classList.remove('drop-target')
        }

        function onDropOnList(ev, trackId) {
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.remove('drop-target')
          if (!currentDragPersonId) return
          movePersonToTrack(currentDragPersonId, trackId)
          currentDragPersonId = null
          setDropZoneActive(false)
        }

        function onDragEnterDropZone(ev) {
          if (!currentDragPersonId) return
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.add('hover')
          if (ev.dataTransfer) {
            ev.dataTransfer.dropEffect = 'move'
          }
        }

        function onDragOverDropZone(ev) {
          if (!currentDragPersonId) return
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.add('hover')
          if (ev.dataTransfer) {
            ev.dataTransfer.dropEffect = 'move'
          }
        }

        function onDragLeaveDropZone(ev) {
          const el = ev.currentTarget
          el.classList.remove('hover')
        }

        function onDropOnDropZone(ev) {
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.remove('hover')
          if (!currentDragPersonId) return
          const personId = currentDragPersonId
          currentDragPersonId = null
          createTrackFromPersonDrop(personId)
          setDropZoneActive(false)
        }

        function render() {
          const container = document.getElementById('tracksContainer')
          if (!container) return
          container.innerHTML = ''

          const defaultCapacityInput = document.getElementById('defaultCapacityInput')
          if (defaultCapacityInput) {
            defaultCapacityInput.value = String(getDefaultTrackCapacity())
          }

          const deleteSelectedTracksButton = document.getElementById('deleteSelectedTracksButton')
          if (deleteSelectedTracksButton) {
            const hasSelected = Array.from(selectedTrackIds).some((id) => {
              const t = getTrackById(id)
              return t && t.type === 'normal'
            })
            deleteSelectedTracksButton.disabled = !hasSelected
          }

          const sweepAllTracksButton = document.getElementById('sweepAllTracksButton')
          if (sweepAllTracksButton) {
            const canSweepAny = state.tracks.some(
              (t) => t.type === 'normal' && t.personIds.length > 1,
            )
            sweepAllTracksButton.disabled = !canSweepAny
          }

          const deleteAllTracksButton = document.getElementById('deleteAllTracksButton')
          if (deleteAllTracksButton) {
            const hasAnyNormalTrack = state.tracks.some((t) => t.type === 'normal')
            deleteAllTracksButton.disabled = !hasAnyNormalTrack
          }

          const capacityNotice = document.getElementById('capacityNotice')
          if (capacityNotice) {
            capacityNotice.innerHTML = ''
            const normalTracks = state.tracks.filter((t) => t.type === 'normal')
            const anyHasCapacity = normalTracks.some((t) => trackHasCapacity(t))
            const onDeck = getTrackByType('on_deck')
            const onDeckCount = onDeck ? onDeck.personIds.length : 0

            let totalAvailableSlots = 0
            let hasInfiniteCapacity = false
            for (const track of normalTracks) {
              if (track.capacity == null) {
                hasInfiniteCapacity = true
                break
              }
              const available = Math.max(0, track.capacity - track.personIds.length)
              totalAvailableSlots += available
            }

            let shortage = 0
            if (!hasInfiniteCapacity && onDeckCount > 0 && totalAvailableSlots < onDeckCount) {
              shortage = onDeckCount - totalAvailableSlots
            }

            if (shortage > 0) {
              const text = document.createElement('span')
              const defaultCap = getDefaultTrackCapacity()
              text.textContent = `Not enough track capacity: ${onDeckCount} on deck but only ${totalAvailableSlots} open slot${totalAvailableSlots === 1 ? '' : 's'}. Allocating will automatically create extra tracks (capacity ${defaultCap}) until everyone fits.`
              capacityNotice.appendChild(text)
            } else if (normalTracks.length && !anyHasCapacity) {
              const text = document.createElement('span')
              text.textContent =
                'All tracks are at capacity; shuffle and drag are disabled until space is freed.'
              capacityNotice.appendChild(text)
            }
          }

          for (const track of state.tracks) {
            const trackEl = document.createElement('section')
            trackEl.className = 'track'
            trackEl.dataset.trackId = track.id

            const header = document.createElement('div')
            header.className = 'track-header'

            const headerRow = document.createElement('div')
            headerRow.className = 'track-header-row'

            if (track.type === 'normal') {
              const selectCheckbox = document.createElement('input')
              selectCheckbox.type = 'checkbox'
              selectCheckbox.className = 'track-select-checkbox'
              selectCheckbox.checked = selectedTrackIds.has(track.id)
              selectCheckbox.title = 'Select track for batch delete'
              selectCheckbox.addEventListener('change', (ev) => {
                if (ev.target.checked) {
                  selectedTrackIds.add(track.id)
                } else {
                  selectedTrackIds.delete(track.id)
                }
                render()
              })
              headerRow.appendChild(selectCheckbox)
            }

            const titleSpan = document.createElement('span')
            titleSpan.className = 'track-title'
            titleSpan.textContent = track.name

            if (track.type === 'normal') {
              titleSpan.style.cursor = 'pointer'
              titleSpan.title = 'Click to rename track'
              titleSpan.addEventListener('click', () => {
                const newName = prompt('New track name?', track.name)
                if (!newName) return
                updateTrackName(track.id, newName)
              })
            }

            headerRow.appendChild(titleSpan)

            if (track.type !== 'normal') {
              const badge = document.createElement('span')
              badge.className = 'badge'
              const dot = document.createElement('span')
              dot.className = 'badge-dot'
              badge.appendChild(dot)
              const label = document.createElement('span')
              label.textContent = track.type === 'on_deck' ? 'On Deck' : 'Out of Office'
              badge.appendChild(label)
              headerRow.appendChild(badge)
            }

            header.appendChild(headerRow)

            const metaRow = document.createElement('div')
            metaRow.className = 'track-meta'

            const countSpan = document.createElement('span')
            const assigned = track.personIds.length
            const capacityLabel =
              track.capacity == null ? 'âˆž' : String(track.capacity)
            countSpan.textContent =
              track.capacity == null
                ? `${assigned} assigned`
                : `${assigned} / ${capacityLabel} assigned`
            metaRow.appendChild(countSpan)

            const isFull =
              track.type === 'normal' &&
              track.capacity != null &&
              assigned >= track.capacity

            if (track.type === 'normal') {
              const capWrapper = document.createElement('div')
              const capLabel = document.createElement('span')
              capLabel.textContent = 'Capacity: '
              capLabel.className = 'muted'
              const capInput = document.createElement('input')
              capInput.type = 'number'
              capInput.min = '1'
              capInput.className = 'capacity-input'
              if (track.capacity != null) {
                capInput.value = String(track.capacity)
              } else {
                capInput.value = ''
              }
              capInput.placeholder = 'âˆž'
              capInput.addEventListener('change', (ev) => {
                const value = ev.target.value.trim()
                if (!value) {
                  updateTrackCapacity(track.id, null)
                } else {
                  const parsed = Number(value)
                  if (Number.isNaN(parsed)) {
                    render()
                  } else {
                    updateTrackCapacity(track.id, parsed)
                  }
                }
              })
              capWrapper.appendChild(capLabel)
              capWrapper.appendChild(capInput)
              metaRow.appendChild(capWrapper)

              if (isFull) {
                const fullLabel = document.createElement('span')
                fullLabel.className = 'track-type'
                fullLabel.textContent = 'Full'
                metaRow.appendChild(fullLabel)
                trackEl.classList.add('track-full')
              }
            } else {
              const typeLabel = document.createElement('span')
              typeLabel.className = 'track-type'
              typeLabel.textContent =
                track.type === 'on_deck' ? 'Source pool' : 'Unavailable'
              metaRow.appendChild(typeLabel)
            }

            header.appendChild(metaRow)

            const actionsRow = document.createElement('div')
            actionsRow.className = 'track-actions'

            const isPendingDelete = pendingDeleteTrackId === track.id

            if (track.type === 'on_deck') {
              const sweepAllocBtn = document.createElement('button')
              sweepAllocBtn.textContent = 'Allocate to tracks'
              sweepAllocBtn.className = 'primary'
              sweepAllocBtn.disabled = !track.personIds.length
              sweepAllocBtn.addEventListener('click', () => {
                sweepAndAllocateFromOnDeck()
              })
              actionsRow.appendChild(sweepAllocBtn)
            } else if (track.type === 'normal') {
              const sweepBtn = document.createElement('button')
              sweepBtn.textContent = 'â¬…ï¸ Sweep (keep one)'
              sweepBtn.title = 'Sweep everyone but one back to On Deck'
              sweepBtn.className = 'primary'
              sweepBtn.addEventListener('click', () => {
                sweepTrackKeepOne(track.id)
              })
              sweepBtn.disabled = track.personIds.length <= 1
              actionsRow.appendChild(sweepBtn)
            }


            if (track.type === 'normal') {
              if (isPendingDelete) {
                const confirmBtn = document.createElement('button')
                confirmBtn.textContent = 'Confirm delete'
                confirmBtn.className = 'danger'
                confirmBtn.addEventListener('click', () => {
                  deleteTrack(track.id)
                })
                actionsRow.appendChild(confirmBtn)

                const cancelBtn = document.createElement('button')
                cancelBtn.textContent = 'Cancel'
                cancelBtn.className = 'ghost'
                cancelBtn.addEventListener('click', () => {
                  pendingDeleteTrackId = null
                  render()
                })
                actionsRow.appendChild(cancelBtn)
              } else {
                const deleteBtn = document.createElement('button')
                deleteBtn.textContent = 'Delete track'
                deleteBtn.className = 'danger'
                deleteBtn.addEventListener('click', () => {
                  pendingDeleteTrackId = track.id
                  render()
                })
                actionsRow.appendChild(deleteBtn)
              }
            }



            header.appendChild(actionsRow)
            trackEl.appendChild(header)

            const peopleList = document.createElement('div')
            peopleList.className =
              'people-list' + (track.personIds.length ? '' : ' empty')
            peopleList.dataset.trackId = track.id
            peopleList.addEventListener('dragover', (ev) =>
              onDragOverList(ev, track.id),
            )
            peopleList.addEventListener('dragleave', onDragLeaveList)
            peopleList.addEventListener('drop', (ev) =>
              onDropOnList(ev, track.id),
            )

            if (!track.personIds.length) {
              const empty = document.createElement('span')
              empty.className = 'muted'
              empty.textContent = 'Empty'
              peopleList.appendChild(empty)
            } else {
              for (const personId of track.personIds) {
                const person = getPersonById(personId)
                if (!person) continue
                const personEl = document.createElement('div')
                personEl.className = 'person'
                personEl.draggable = true
                personEl.addEventListener('dragstart', (ev) =>
                  onDragStartPerson(ev, person.id),
                )
                personEl.addEventListener('dragend', onDragEndPerson)

                const nameSpan = document.createElement('span')
                nameSpan.className = 'person-name'
                nameSpan.textContent = person.name
                nameSpan.style.cursor = 'pointer'
                nameSpan.title = 'Click to rename person'
                nameSpan.addEventListener('click', () => {
                  const newName = prompt('New name?', person.name)
                  if (!newName) return
                  updatePersonName(person.id, newName)
                })
                personEl.appendChild(nameSpan)

                const actions = document.createElement('div')
                actions.className = 'person-actions'

                const isPendingRetire = pendingRetirePersonId === person.id

                if (isPendingRetire) {
                  personEl.classList.add('person-pending-retire')
                }

                if (!isPendingRetire) {
                  const shuffleBtn = document.createElement('button')
                  shuffleBtn.textContent = 'ðŸ”€'
                  shuffleBtn.title = 'Shuffle to another track'
                  shuffleBtn.className = 'primary'
                  shuffleBtn.dataset.label = 'Shuffle'
                  shuffleBtn.addEventListener('click', () => {
                    shufflePerson(person.id)
                  })
                  actions.appendChild(shuffleBtn)

                  if (track.type !== 'on_deck') {
                    const sweepBtn = document.createElement('button')
                    sweepBtn.textContent = 'â¬…ï¸'
                    sweepBtn.title = 'Sweep to On Deck'
                    sweepBtn.addEventListener('click', () => {
                      sweepPerson(person.id)
                    })
                    actions.appendChild(sweepBtn)
                  }

                  const moveCandidates = state.tracks.filter((t) => {
                    if (t.id === track.id) return false
                    if (t.type === 'out_of_office') return false
                    return trackHasCapacity(t)
                  })

                  const moveSelect = document.createElement('select')
                  moveSelect.setAttribute('aria-label', 'Move to track')

                  const placeholderOption = document.createElement('option')
                  placeholderOption.value = ''
                  placeholderOption.textContent = 'Moveâ€¦'
                  placeholderOption.disabled = true
                  placeholderOption.selected = true
                  moveSelect.appendChild(placeholderOption)

                  for (const t of moveCandidates) {
                    const opt = document.createElement('option')
                    opt.value = t.id
                    opt.textContent = t.name
                    moveSelect.appendChild(opt)
                  }

                  const newTrackOption = document.createElement('option')
                  newTrackOption.value = NEW_TRACK_OPTION_VALUE
                  newTrackOption.textContent = 'âž• New trackâ€¦'
                  moveSelect.appendChild(newTrackOption)

                  moveSelect.addEventListener('change', (ev) => {
                    const targetId = ev.target.value
                    if (!targetId) return
                    if (targetId === NEW_TRACK_OPTION_VALUE) {
                      createTrackFromPersonDrop(person.id)
                      return
                    }
                    movePersonToTrack(person.id, targetId)
                  })

                  actions.appendChild(moveSelect)
                }

                const retireBtn = document.createElement('button')
                if (isPendingRetire) {
                  retireBtn.textContent = 'âœ…'
                  retireBtn.className = 'danger'
                  retireBtn.title = `Confirm retire ${person.name}`
                } else {
                  retireBtn.textContent = 'ðŸ‘‹'
                  retireBtn.className = 'retire-button'
                  retireBtn.title = 'Retire from planner'
                }
                retireBtn.addEventListener('click', () => {
                  if (pendingRetirePersonId === person.id) {
                    retirePerson(person.id)
                  } else {
                    pendingRetirePersonId = person.id
                    render()
                  }
                })
                actions.appendChild(retireBtn)

                if (isPendingRetire) {
                  const cancelRetireBtn = document.createElement('button')
                  cancelRetireBtn.textContent = 'âœ–ï¸'
                  cancelRetireBtn.title = 'Cancel'
                  cancelRetireBtn.addEventListener('click', () => {
                    pendingRetirePersonId = null
                    render()
                  })
                  actions.appendChild(cancelRetireBtn)
                }

                personEl.appendChild(actions)
                peopleList.appendChild(personEl)
              }
            }

            trackEl.appendChild(peopleList)
            container.appendChild(trackEl)
          }

          const dropZone = document.createElement('div')
          dropZone.id = 'createTrackDropZone'
          dropZone.className = 'create-track-drop-zone'
          dropZone.textContent = 'Drop to create a new track'
          dropZone.setAttribute('role', 'button')
          dropZone.setAttribute('aria-hidden', currentDragPersonId ? 'false' : 'true')
          dropZone.setAttribute('aria-label', 'Drop to create a new track')
          dropZone.addEventListener('dragenter', onDragEnterDropZone)
          dropZone.addEventListener('dragover', onDragOverDropZone)
          dropZone.addEventListener('dragleave', onDragLeaveDropZone)
          dropZone.addEventListener('drop', onDropOnDropZone)
          if (currentDragPersonId) {
            dropZone.classList.add('visible')
          }

          container.appendChild(dropZone)
        }

        function init() {
          state = loadState()

          const addPeopleButton = document.getElementById('addPeopleButton')
          if (addPeopleButton) {
            addPeopleButton.addEventListener('click', addPeopleFromTextarea)
          }

          const resetPlanButton = document.getElementById('resetPlanButton')
          if (resetPlanButton) {
            resetPlanButton.addEventListener('click', resetPlan)
          }

          const deleteSelectedTracksButton = document.getElementById('deleteSelectedTracksButton')
          if (deleteSelectedTracksButton) {
            deleteSelectedTracksButton.addEventListener('click', () => {
              deleteSelectedTracks()
            })
          }

          const sweepAllTracksButton = document.getElementById('sweepAllTracksButton')
          if (sweepAllTracksButton) {
            sweepAllTracksButton.addEventListener('click', () => {
              sweepAllTracksKeepOne()
            })
          }

          const deleteAllTracksButton = document.getElementById('deleteAllTracksButton')
          if (deleteAllTracksButton) {
            deleteAllTracksButton.addEventListener('click', () => {
              deleteAllTracks()
            })
          }

          const defaultCapacityInput = document.getElementById('defaultCapacityInput')
          if (defaultCapacityInput) {
            defaultCapacityInput.addEventListener('change', (ev) => {
              const raw = ev.target.value.trim()
              let value = Number(raw)
              if (!raw || Number.isNaN(value) || value < 1) {
                value = 2
              }
              state.defaultTrackCapacity = value
              saveState()
              render()
            })
          }

          render()
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init)
        } else {
          init()
        }
      })()
    </script>
  </body>
</html>
