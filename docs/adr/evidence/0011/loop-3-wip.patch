diff --git a/index.html b/index.html
index cfd7541..050047c 100644
--- a/index.html
+++ b/index.html
@@ -1049,7 +1049,16 @@
           if (persist) saveBackendDrawerOpen(open)
         }
 
-        function showToast(message, durationMs = 2500) {
+        let toastTimerId = null
+
+        function showToast(message, options = {}) {
+          const sticky = typeof options === 'object' && options.sticky === true
+          const durationMs =
+            typeof options === 'number'
+              ? options
+              : typeof options.durationMs === 'number'
+                ? options.durationMs
+                : 2500
           let toast = document.getElementById('toast')
           if (!toast) {
             toast = document.createElement('div')
@@ -1059,9 +1068,13 @@
           }
           toast.textContent = message
           toast.classList.add('visible')
-          window.setTimeout(() => {
-            toast.classList.remove('visible')
-          }, durationMs)
+          toast.dataset.sticky = sticky ? 'true' : 'false'
+          if (toastTimerId) window.clearTimeout(toastTimerId)
+          if (!sticky) {
+            toastTimerId = window.setTimeout(() => {
+              toast.classList.remove('visible')
+            }, durationMs)
+          }
         }
 
         function updateHeartbeatIndicator(status) {
@@ -1219,6 +1232,9 @@
               signal: controller.signal,
             })
             backendConfig.reachability = response.ok ? 'connected' : 'offline'
+            if (backendConfig.reachability === 'connected') {
+              backendSaveBlocked = false
+            }
           } catch (err) {
             backendConfig.reachability = 'offline'
           } finally {
@@ -1344,7 +1360,12 @@
         }
 
         async function saveToBackend() {
+          const options = arguments.length && typeof arguments[0] === 'object' ? arguments[0] : {}
+          const reason = options.reason || 'manual'
+          const keepalive = Boolean(options.keepalive)
+          const suppressToast = Boolean(options.suppressToast)
           if (!isBackendEnabled()) return false
+          if (backendSaveBlocked && reason === 'autosave') return false
           const workspaceId = currentWorkspaceId()
           const snapshot = { id: workspaceId, name: 'Workspace', data: state }
           const method = workspaceId ? 'PUT' : 'POST'
@@ -1360,13 +1381,18 @@
                   ? { ...snapshot, clientTempId: workspaceMeta.clientTempId }
                   : snapshot,
               ),
+              keepalive,
             })
             if (!response.ok) {
               console.warn('Backend save failed', response.status)
               backendConfig.reachability = 'offline'
+              backendSaveBlocked = true
               saveBackendConfig(backendConfig)
               updateBackendStatusBadge(backendConfig.reachability, 'Backend save failed; staying local.')
               disableBackendButtons(true)
+              if (!suppressToast) {
+                showToast('Backend save failed.', { sticky: true })
+              }
               return false
             }
             const data = await response.json()
@@ -1380,17 +1406,56 @@
               window.location.hash = `${WORKSPACE_HASH_PREFIX}${data.id}`
             }
             dirtySinceServerLoad = false
+            backendSaveBlocked = false
+            if (!suppressToast) {
+              showToast('Backend saved.', { sticky: false })
+            }
             return true
           } catch (err) {
             console.warn('Backend save error', err)
             backendConfig.reachability = 'offline'
+            backendSaveBlocked = true
             saveBackendConfig(backendConfig)
             updateBackendStatusBadge(backendConfig.reachability, 'Backend save failed; staying local.')
             disableBackendButtons(true)
+            if (!suppressToast) {
+              showToast('Backend save failed.', { sticky: true })
+            }
+            return false
+          }
+        }
+
+        function attemptBeaconSave(snapshot, baseUrl, workspaceId) {
+          if (!navigator.sendBeacon) return false
+          const payload =
+            workspaceId == null
+              ? { ...snapshot, clientTempId: workspaceMeta.clientTempId }
+              : { ...snapshot, __method: 'PUT' }
+          const url = workspaceId ? `${baseUrl}/workspaces/${workspaceId}` : `${baseUrl}/workspaces`
+          try {
+            return navigator.sendBeacon(url, JSON.stringify(payload))
+          } catch (err) {
             return false
           }
         }
 
+        async function handleBeforeUnload(event) {
+          if (!isBackendEnabled()) return
+          if (!dirtySinceServerLoad) return
+          const workspaceId = currentWorkspaceId()
+          const baseUrl = currentBackendBaseUrl()
+          const snapshot = { id: workspaceId, name: 'Workspace', data: state }
+          if (backendSaveBlocked) {
+            if (event) {
+              if (typeof event.preventDefault === 'function') event.preventDefault()
+              event.returnValue = ''
+            }
+            attemptBeaconSave(snapshot, baseUrl, workspaceId)
+            return
+          }
+          saveToBackend({ reason: 'autosave', keepalive: true, suppressToast: true })
+        }
+
         function revertToLocal() {
           backendConfig.backendUrl = ''
           backendConfig.reachability = 'offline'
@@ -1398,6 +1463,7 @@
           saveBackendConfig(backendConfig)
           updateBackendStatusBadge(backendConfig.reachability)
           stopBackendHeartbeat()
+          backendSaveBlocked = false
           setBackendDrawerOpen(false, true)
         }
  
@@ -1797,9 +1863,11 @@
         let undoButtonEl = null
         let redoButtonEl = null
         let historyShortcutBound = false
+        let beforeUnloadBound = false
         let historyOverlayEl = null
         let suppressTenureIndicatorClickUntil = 0
         let dirtySinceServerLoad = false
+        let backendSaveBlocked = false
 
         function createInitialState() {
 
@@ -5288,6 +5356,7 @@
             loadFromBackend,
             saveToBackend,
             revertToLocal,
+            handleBeforeUnload,
             workspaceMeta,
             getState: () => state,
             setState: (next, markDirty = true) => {
@@ -5298,6 +5367,9 @@
             setDirtySinceServerLoad: (value) => {
               dirtySinceServerLoad = Boolean(value)
             },
+            setBackendSaveBlocked: (value) => {
+              backendSaveBlocked = Boolean(value)
+            },
           }
         }
 
@@ -5447,6 +5519,11 @@
             startBackendHeartbeat()
           }
 
+          if (!beforeUnloadBound) {
+            window.addEventListener('beforeunload', handleBeforeUnload)
+            beforeUnloadBound = true
+          }
+
           undoButtonEl = document.getElementById('undoButton')
           if (undoButtonEl) {
             undoButtonEl.addEventListener('click', (ev) => {
diff --git a/tests/backend-status.test.js b/tests/backend-status.test.js
index 7440df8..b4d3e98 100755
--- a/tests/backend-status.test.js
+++ b/tests/backend-status.test.js
@@ -263,6 +263,61 @@ describe('ADR-0011 backend auto-load and drawer', () => {
   })
 })
 
+describe('ADR-0011 autosave and toast behaviour', () => {
+  it('blocks unload when autosave previously failed', async () => {
+    const dom = createDom()
+    const hooks = await waitForHooks(dom.window)
+    hooks.backendConfig.backendUrl = 'https://api.example.com'
+    hooks.backendConfig.reachability = 'connected'
+    hooks.setDirtySinceServerLoad(true)
+    hooks.setBackendSaveBlocked(true)
+
+    const event = { preventDefault: () => {}, returnValue: undefined }
+    await hooks.handleBeforeUnload(event)
+
+    expect(event.returnValue).toBe('')
+    expect(dom.window._sendBeaconMock).toHaveBeenCalled()
+  })
+
+  it('marks failure toast as sticky on save failure', async () => {
+    const fetchMock = vi.fn(() => Promise.reject(new Error('server down')))
+    const dom = createDom({ fetchMock })
+    const hooks = await waitForHooks(dom.window)
+    hooks.backendConfig.backendUrl = 'https://api.example.com'
+    hooks.backendConfig.reachability = 'connected'
+    hooks.workspaceMeta.workspaceId = 'w1'
+
+    const ok = await hooks.saveToBackend()
+    expect(ok).toBe(false)
+
+    const toast = dom.window.document.getElementById('toast')
+    expect(toast).not.toBeNull()
+    expect(toast?.dataset.sticky).toBe('true')
+    expect(toast?.classList.contains('visible')).toBe(true)
+  })
+
+  it('marks success toast as auto-dismiss on save success', async () => {
+    const fetchMock = vi.fn(() =>
+      Promise.resolve({
+        ok: true,
+        json: async () => ({ id: 'w1', name: 'Workspace', data: {} }),
+      }),
+    )
+    const dom = createDom({ fetchMock })
+    const hooks = await waitForHooks(dom.window)
+    hooks.backendConfig.backendUrl = 'https://api.example.com'
+    hooks.backendConfig.reachability = 'connected'
+    hooks.workspaceMeta.workspaceId = 'w1'
+
+    const ok = await hooks.saveToBackend()
+    expect(ok).toBe(true)
+
+    const toast = dom.window.document.getElementById('toast')
+    expect(toast).not.toBeNull()
+    expect(toast?.dataset.sticky).toBe('false')
+  })
+})
+
 function waitForHooks(window, timeoutMs = 2000) {
   const start = Date.now()
   return new Promise((resolve, reject) => {
@@ -297,6 +352,11 @@ function createDom(options = {}) {
         writeText: () => Promise.resolve(),
         readText: () => Promise.resolve(''),
       }
+      window.navigator.sendBeacon = (...args) => {
+        const mock = window._sendBeaconMock
+        return mock(...args)
+      }
+      window._sendBeaconMock = vi.fn(() => true)
       if (backendConfig) {
         window.localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(backendConfig))
       }
