<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pair / Mob Planner</title>
    <style>
      :root {
        --bg: #f4f4f4;
        --card-bg: #ffffff;
        --border: #dddddd;
        --accent: #0070f3;
        --accent-soft: #e3f1ff;
        --danger: #b3261e;
        --muted: #666666;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        margin: 24px;
        background: var(--bg);
        color: #111827;
      }

      h1 {
        margin: 0 0 4px;
        font-size: 1.6rem;
      }

      p {
        margin: 0 0 12px;
        color: var(--muted);
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
      }

      .layout-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 16px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      textarea {
        width: 100%;
        min-height: 80px;
        padding: 8px;
        font-size: 14px;
        resize: vertical;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
      }

      button {
        padding: 6px 12px;
        cursor: pointer;
        font-size: 13px;
        border-radius: 4px;
        border: 1px solid var(--border);
        background: #ffffff;
        color: #111827;
      }

      button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #ffffff;
      }

      button.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: #ffffff;
      }

      button.ghost {
        background: transparent;
      }

      button:disabled {
        opacity: 0.5;
        cursor: default;
      }

      .tracks-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 8px 0 12px;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tracks-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
        align-items: flex-start;
      }

      .track {
        background: var(--card-bg);
        border-radius: 6px;
        border: 1px solid var(--border);
        padding: 8px;
        display: flex;
        flex-direction: column;
        min-height: 120px;
      }

      .track-header {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 6px;
      }

      .track-header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
      }

      .track-title {
        font-weight: 600;
        font-size: 0.95rem;
      }

      .track-type {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }

      .track-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        font-size: 0.75rem;
      }

      .capacity-input {
        width: 60px;
        padding: 3px 4px;
        font-size: 0.75rem;
      }

      .track-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }

      .people-list {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 4px;
        border-radius: 4px;
        background: #f9fafb;
        min-height: 60px;
      }

      .people-list.empty {
        font-size: 0.8rem;
        color: var(--muted);
        align-items: center;
        justify-content: center;
        display: flex;
      }

      .people-list.drop-target {
        outline: 2px dashed var(--accent);
        background: var(--accent-soft);
      }

      .person {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        padding: 4px 6px;
        border-radius: 4px;
        background: #ffffff;
        border: 1px solid var(--border);
        font-size: 0.85rem;
      }

      .person-name {
        flex: 1;
        word-break: break-word;
      }

      .person-actions {
        display: flex;
        gap: 2px;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e5e7eb;
        font-size: 0.7rem;
      }

      .badge-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--accent);
        margin-right: 4px;
      }

      .muted {
        color: var(--muted);
      }

      @media (max-width: 600px) {
        body {
          margin: 12px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="layout-header">
        <div>
          <h1>Pair / Mob Planner</h1>
          <p>Manage tracks and quickly reshuffle people using local storage.</p>
        </div>
        <div class="controls">
          <button id="resetPlanButton" class="ghost">Reset plan</button>
          <a href="/pairs.html">
            <button type="button" class="ghost">Open simple pair randomizer</button>
          </a>
        </div>
      </div>

      <section class="stack">
        <label for="bulkNamesInput" style="font-size:0.85rem;">Add people (one name per line):</label>
        <textarea
          id="bulkNamesInput"
          placeholder="Alice&#10;Bob&#10;Charlie&#10;Dana"
        ></textarea>
        <div>
          <button id="addPeopleButton" class="primary">Add people to On Deck</button>
        </div>
      </section>

      <section class="tracks-toolbar">
        <div class="muted" style="font-size:0.8rem;">
          Tracks: On Deck distributes into all normal tracks. Out of Office is excluded from random allocation.
        </div>
        <button id="addTrackButton">Add track</button>
      </section>

      <section id="tracksContainer" class="tracks-grid" aria-label="Tracks"></section>
    </main>

    <script>
      ;(function () {
        const STORAGE_KEY = 'pairPlanner:v1'

        /**
         * @typedef {{ id: string, name: string }} Person
         * @typedef {{ id: string, name: string, type: 'normal' | 'on_deck' | 'out_of_office', capacity: number | null, personIds: string[] }} Track
         * @typedef {{ people: Person[], tracks: Track[], nextPersonId: number, nextTrackId: number }} PlannerState
         */

        /** @type {PlannerState} */
        let state
        let currentDragPersonId = null

        function createInitialState() {
          return {
            people: [],
            tracks: [
              {
                id: 'on_deck',
                name: 'On Deck',
                type: 'on_deck',
                capacity: null,
                personIds: [],
              },
              {
                id: 'out_of_office',
                name: 'Out of Office',
                type: 'out_of_office',
                capacity: null,
                personIds: [],
              },
              {
                id: 'track-1',
                name: 'Track A',
                type: 'normal',
                capacity: 2,
                personIds: [],
              },
            ],
            nextPersonId: 1,
            nextTrackId: 2,
          }
        }

        function loadState() {
          try {
            const raw = window.localStorage.getItem(STORAGE_KEY)
            if (!raw) return createInitialState()
            const parsed = JSON.parse(raw)
            if (!parsed || !Array.isArray(parsed.people) || !Array.isArray(parsed.tracks)) {
              return createInitialState()
            }
            if (typeof parsed.nextPersonId !== 'number') parsed.nextPersonId = 1
            if (typeof parsed.nextTrackId !== 'number') parsed.nextTrackId = 1
            return parsed
          } catch (e) {
            console.warn('Failed to load planner state, resetting.', e)
            return createInitialState()
          }
        }

        function saveState() {
          try {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
          } catch (e) {
            console.warn('Failed to save planner state.', e)
          }
        }

        function getTrackByType(type) {
          return state.tracks.find((t) => t.type === type) || null
        }

        function getTrackById(id) {
          return state.tracks.find((t) => t.id === id) || null
        }

        function getPersonById(id) {
          return state.people.find((p) => p.id === id) || null
        }

        function trackHasCapacity(track) {
          if (track.capacity == null) return true
          return track.personIds.length < track.capacity
        }

        function addPeopleFromTextarea() {
          const textarea = document.getElementById('bulkNamesInput')
          if (!textarea) return
          const value = textarea.value || ''
          const lines = value
            .split(/\n+/)
            .map((l) => l.trim())
            .filter(Boolean)
          if (!lines.length) {
            alert('Please enter at least one name.')
            return
          }

          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          for (const name of lines) {
            const person = {
              id: 'p-' + state.nextPersonId++,
              name,
            }
            state.people.push(person)
            onDeck.personIds.push(person.id)
          }

          textarea.value = ''
          saveState()
          render()
        }

        function resetPlan() {
          if (!confirm('Reset plan? This will clear all tracks and people for this tool on this browser.')) {
            return
          }
          window.localStorage.removeItem(STORAGE_KEY)
          state = createInitialState()
          render()
        }

        function addTrack() {
          const name = prompt('Track name?', 'New Track')
          if (!name) return
          const track = {
            id: 'track-' + state.nextTrackId++,
            name: name.trim(),
            type: 'normal',
            capacity: 2,
            personIds: [],
          }
          state.tracks.push(track)
          saveState()
          render()
        }

        function movePersonToTrack(personId, targetTrackId) {
          const person = getPersonById(personId)
          const target = getTrackById(targetTrackId)
          if (!person || !target) return

          if (!trackHasCapacity(target)) {
            alert('Track is at capacity.')
            return
          }

          let currentTrack = null
          for (const track of state.tracks) {
            const idx = track.personIds.indexOf(personId)
            if (idx !== -1) {
              currentTrack = track
              track.personIds.splice(idx, 1)
              break
            }
          }

          // Avoid duplicate if we somehow didn't find original track.
          if (!target.personIds.includes(personId)) {
            target.personIds.push(personId)
          }

          saveState()
          render()
        }

        function sweepTrackKeepOne(trackId) {
          const track = getTrackById(trackId)
          if (!track) return
          if (track.type === 'on_deck') return
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          if (track.personIds.length <= 1) return

          const idxToKeep = Math.floor(Math.random() * track.personIds.length)
          const keepId = track.personIds[idxToKeep]
          const toMove = track.personIds.filter((id) => id !== keepId)

          track.personIds = [keepId]
          onDeck.personIds.push(...toMove)

          saveState()
          render()
        }

        function sweepAndAllocateFromOnDeck() {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck || !onDeck.personIds.length) return

          const normalTracks = state.tracks.filter((t) => t.type === 'normal')
          if (!normalTracks.length) return

          // Create a shuffled copy of on deck people
          const remaining = onDeck.personIds.slice()
          for (let i = remaining.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1))
            ;[remaining[i], remaining[j]] = [remaining[j], remaining[i]]
          }

          for (const track of normalTracks) {
            if (!remaining.length) break
            const capacity = track.capacity == null ? Infinity : track.capacity
            let availableSlots = capacity - track.personIds.length
            while (availableSlots > 0 && remaining.length) {
              const id = remaining.pop()
              if (!id) break
              track.personIds.push(id)
              availableSlots--
            }
          }

          onDeck.personIds = remaining

          saveState()
          render()
        }

        function deleteTrack(trackId) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return

          if (
            !confirm(
              `Delete track "${track.name}"? All people on this track will be moved back to On Deck.`,
            )
          ) {
            return
          }

          onDeck.personIds.push(...track.personIds)
          state.tracks = state.tracks.filter((t) => t.id !== trackId)

          saveState()
          render()
        }

        function updateTrackCapacity(trackId, newCapacity) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return

          const originalCapacity = track.capacity

          if (newCapacity == null) {
            track.capacity = null
          } else if (newCapacity < 1) {
            alert('Capacity must be at least 1.')
            return
          } else {
            if (track.personIds.length > newCapacity) {
              alert(
                'Capacity is lower than the number of assigned people. Remove some people first or sweep the track.',
              )
              // Do not update capacity; revert via re-render.
              render()
              return
            }
            track.capacity = newCapacity
          }

          if (track.capacity !== originalCapacity) {
            saveState()
            render()
          }
        }

        function updateTrackName(trackId, newName) {
          const track = getTrackById(trackId)
          if (!track || track.type !== 'normal') return
          const trimmed = newName.trim()
          if (!trimmed) return
          track.name = trimmed
          saveState()
          // No need to re-render for a simple inline update, but keep it consistent.
          render()
        }

        function sweepPerson(personId) {
          const onDeck = getTrackByType('on_deck')
          if (!onDeck) return
          movePersonToTrack(personId, onDeck.id)
        }

        function shufflePerson(personId) {
          const currentTrack = state.tracks.find((t) => t.personIds.includes(personId))
          if (!currentTrack) return

          const candidates = state.tracks.filter((t) => {
            if (t.id === currentTrack.id) return false
            if (t.type === 'out_of_office') return false
            if (t.type === 'on_deck') return false
            return trackHasCapacity(t)
          })

          if (!candidates.length) {
            alert('No other track has capacity to accept this person.')
            return
          }

          const idx = Math.floor(Math.random() * candidates.length)
          const target = candidates[idx]
          movePersonToTrack(personId, target.id)
        }

        function retirePerson(personId) {
          const person = getPersonById(personId)
          if (!person) return
          if (
            !confirm(
              `Retire "${person.name}"? They will be removed from all tracks and this planner.`,
            )
          ) {
            return
          }

          state.people = state.people.filter((p) => p.id !== personId)
          for (const track of state.tracks) {
            track.personIds = track.personIds.filter((id) => id !== personId)
          }

          saveState()
          render()
        }

        function onDragStartPerson(ev, personId) {
          currentDragPersonId = personId
          ev.dataTransfer.effectAllowed = 'move'
        }

        function onDragEndPerson() {
          currentDragPersonId = null
          const lists = document.querySelectorAll('.people-list')
          lists.forEach((el) => el.classList.remove('drop-target'))
        }

        function onDragOverList(ev, trackId) {
          if (!currentDragPersonId) return
          ev.preventDefault()
          ev.dataTransfer.dropEffect = 'move'
          const el = ev.currentTarget
          el.classList.add('drop-target')
        }

        function onDragLeaveList(ev) {
          const el = ev.currentTarget
          el.classList.remove('drop-target')
        }

        function onDropOnList(ev, trackId) {
          ev.preventDefault()
          const el = ev.currentTarget
          el.classList.remove('drop-target')
          if (!currentDragPersonId) return
          movePersonToTrack(currentDragPersonId, trackId)
          currentDragPersonId = null
        }

        function render() {
          const container = document.getElementById('tracksContainer')
          if (!container) return
          container.innerHTML = ''

          for (const track of state.tracks) {
            const trackEl = document.createElement('section')
            trackEl.className = 'track'
            trackEl.dataset.trackId = track.id

            const header = document.createElement('div')
            header.className = 'track-header'

            const headerRow = document.createElement('div')
            headerRow.className = 'track-header-row'
            const titleSpan = document.createElement('span')
            titleSpan.className = 'track-title'
            titleSpan.textContent = track.name

            if (track.type === 'normal') {
              titleSpan.style.cursor = 'pointer'
              titleSpan.title = 'Click to rename track'
              titleSpan.addEventListener('click', () => {
                const newName = prompt('Track name?', track.name)
                if (!newName) return
                updateTrackName(track.id, newName)
              })
            }

            headerRow.appendChild(titleSpan)

            if (track.type !== 'normal') {
              const badge = document.createElement('span')
              badge.className = 'badge'
              const dot = document.createElement('span')
              dot.className = 'badge-dot'
              badge.appendChild(dot)
              const label = document.createElement('span')
              label.textContent = track.type === 'on_deck' ? 'On Deck' : 'Out of Office'
              badge.appendChild(label)
              headerRow.appendChild(badge)
            }

            header.appendChild(headerRow)

            const metaRow = document.createElement('div')
            metaRow.className = 'track-meta'

            const countSpan = document.createElement('span')
            const assigned = track.personIds.length
            const capacityLabel =
              track.capacity == null ? '∞' : String(track.capacity)
            countSpan.textContent =
              track.capacity == null
                ? `${assigned} assigned`
                : `${assigned} / ${capacityLabel} assigned`
            metaRow.appendChild(countSpan)

            if (track.type === 'normal') {
              const capWrapper = document.createElement('div')
              const capLabel = document.createElement('span')
              capLabel.textContent = 'Capacity: '
              capLabel.className = 'muted'
              const capInput = document.createElement('input')
              capInput.type = 'number'
              capInput.min = '1'
              capInput.className = 'capacity-input'
              if (track.capacity != null) {
                capInput.value = String(track.capacity)
              } else {
                capInput.value = ''
              }
              capInput.placeholder = '∞'
              capInput.addEventListener('change', (ev) => {
                const value = ev.target.value.trim()
                if (!value) {
                  updateTrackCapacity(track.id, null)
                } else {
                  const parsed = Number(value)
                  if (Number.isNaN(parsed)) {
                    render()
                  } else {
                    updateTrackCapacity(track.id, parsed)
                  }
                }
              })
              capWrapper.appendChild(capLabel)
              capWrapper.appendChild(capInput)
              metaRow.appendChild(capWrapper)
            } else {
              const typeLabel = document.createElement('span')
              typeLabel.className = 'track-type'
              typeLabel.textContent =
                track.type === 'on_deck' ? 'Source pool' : 'Unavailable'
              metaRow.appendChild(typeLabel)
            }

            header.appendChild(metaRow)

            const actionsRow = document.createElement('div')
            actionsRow.className = 'track-actions'

            if (track.type === 'on_deck') {
              const sweepAllocBtn = document.createElement('button')
              sweepAllocBtn.textContent = 'Sweep & allocate'
              sweepAllocBtn.className = 'primary'
              sweepAllocBtn.disabled = !track.personIds.length
              sweepAllocBtn.addEventListener('click', () => {
                sweepAndAllocateFromOnDeck()
              })
              actionsRow.appendChild(sweepAllocBtn)
            } else if (track.type === 'normal') {
              const sweepBtn = document.createElement('button')
              sweepBtn.textContent = 'Sweep (keep one)'
              sweepBtn.addEventListener('click', () => {
                sweepTrackKeepOne(track.id)
              })
              sweepBtn.disabled = track.personIds.length <= 1
              actionsRow.appendChild(sweepBtn)
            }

            if (track.type === 'normal') {
              const deleteBtn = document.createElement('button')
              deleteBtn.textContent = 'Delete track'
              deleteBtn.className = 'danger'
              deleteBtn.addEventListener('click', () => {
                deleteTrack(track.id)
              })
              actionsRow.appendChild(deleteBtn)
            }

            header.appendChild(actionsRow)
            trackEl.appendChild(header)

            const peopleList = document.createElement('div')
            peopleList.className =
              'people-list' + (track.personIds.length ? '' : ' empty')
            peopleList.dataset.trackId = track.id
            peopleList.addEventListener('dragover', (ev) =>
              onDragOverList(ev, track.id),
            )
            peopleList.addEventListener('dragleave', onDragLeaveList)
            peopleList.addEventListener('drop', (ev) =>
              onDropOnList(ev, track.id),
            )

            if (!track.personIds.length) {
              const empty = document.createElement('span')
              empty.className = 'muted'
              empty.textContent = 'Empty'
              peopleList.appendChild(empty)
            } else {
              for (const personId of track.personIds) {
                const person = getPersonById(personId)
                if (!person) continue
                const personEl = document.createElement('div')
                personEl.className = 'person'
                personEl.draggable = true
                personEl.addEventListener('dragstart', (ev) =>
                  onDragStartPerson(ev, person.id),
                )
                personEl.addEventListener('dragend', onDragEndPerson)

                const nameSpan = document.createElement('span')
                nameSpan.className = 'person-name'
                nameSpan.textContent = person.name
                personEl.appendChild(nameSpan)

                const actions = document.createElement('div')
                actions.className = 'person-actions'

                if (track.type !== 'on_deck') {
                  const sweepBtn = document.createElement('button')
                  sweepBtn.textContent = 'Sweep'
                  sweepBtn.addEventListener('click', () => {
                    sweepPerson(person.id)
                  })
                  actions.appendChild(sweepBtn)
                }

                const shuffleBtn = document.createElement('button')
                shuffleBtn.textContent = 'Shuffle'
                shuffleBtn.addEventListener('click', () => {
                  shufflePerson(person.id)
                })
                actions.appendChild(shuffleBtn)

                const retireBtn = document.createElement('button')
                retireBtn.textContent = 'Retire'
                retireBtn.addEventListener('click', () => {
                  retirePerson(person.id)
                })
                actions.appendChild(retireBtn)

                personEl.appendChild(actions)
                peopleList.appendChild(personEl)
              }
            }

            trackEl.appendChild(peopleList)
            container.appendChild(trackEl)
          }
        }

        function init() {
          state = loadState()

          const addPeopleButton = document.getElementById('addPeopleButton')
          if (addPeopleButton) {
            addPeopleButton.addEventListener('click', addPeopleFromTextarea)
          }

          const resetPlanButton = document.getElementById('resetPlanButton')
          if (resetPlanButton) {
            resetPlanButton.addEventListener('click', resetPlan)
          }

          const addTrackButton = document.getElementById('addTrackButton')
          if (addTrackButton) {
            addTrackButton.addEventListener('click', addTrack)
          }

          render()
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init)
        } else {
          init()
        }
      })()
    </script>
  </body>
  </html>
